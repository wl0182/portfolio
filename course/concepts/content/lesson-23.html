<!doctype html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lesson 23 - Spring Boot Async Programming and Messaging with Kafka Part 1</title>
    <meta name="description" content="Master asynchronous programming in Spring Boot and get started with Apache Kafka: async processing, Kafka introduction, setup, and producing/consuming messages with practical examples and best practices." />
    <script>(function(){try{const t=localStorage.getItem('theme');const d=matchMedia('(prefers-color-scheme: dark)').matches;if(t==='dark'||(!t&&d))document.documentElement.classList.add('dark');}catch{}})();</script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ sans:["Inter var","Inter","ui-sans-serif","system-ui","-apple-system","Segoe UI","Roboto","Helvetica","Arial","Noto Sans","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"] } } } };
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css" />
    <link rel="stylesheet" href="../../../tutorials/tutorials.css" />
  </head>
  <body class="bg-white text-slate-800 antialiased dark:bg-slate-950 dark:text-slate-100">
    <div aria-hidden="true" class="pointer-events-none fixed inset-0 -z-10"><div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 via-fuchsia-500/10 to-emerald-500/10 blur-2xl"></div></div>

    <header class="z-20 backdrop-blur supports-[backdrop-filter]:bg-white/60 supports-[backdrop-filter]:dark:bg-slate-950/40 border-b border-slate-200/60 dark:border-slate-800/60">
      <div class="mx-auto flex max-w-7xl items-center justify-between gap-4 px-6 py-4">
        <a href="../../../" class="group inline-flex items-center gap-3">
          <span class="grid h-9 w-9 place-items-center rounded-lg bg-indigo-600 text-white shadow-md shadow-indigo-600/30">WL</span>
          <div class="leading-tight">
            <div class="text-sm text-slate-500 dark:text-slate-400">Java Full Stack Developer</div>
            <div class="font-semibold">Wassim Lagnaoui</div>
          </div>
        </a>
        <nav class="hidden items-center gap-6 md:flex">
          <a href="../../../#about" class="hover:text-indigo-600 dark:hover:text-indigo-400">About</a>
          <a href="../../../blog/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Blog</a>
          <a href="../../../#skills" class="hover:text-indigo-600 dark:hover:text-indigo-400">Skills</a>
          <a href="../../../projects/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Projects</a>
          <a href="../../../tutorials/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Tutorials</a>
          <a href="../../" class="text-indigo-600 dark:text-indigo-400">Courses</a>
        </nav>
        <button id="themeToggle" class="inline-flex items-center justify-center rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800" aria-label="Toggle theme">
          <svg class="h-5 w-5 dark:hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v2m0 14v2M5.64 5.64l1.41 1.41M16.95 16.95l1.41 1.41M3 12h2m14 0h2M5.64 18.36l1.41-1.41M16.95 7.05l1.41-1.41"/><circle cx="12" cy="12" r="4"/></svg>
          <svg class="hidden h-5 w-5 dark:block" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        </button>
      </div>
    </header>

    <main class="mx-auto max-w-7xl px-6 py-10">
      <div class="lg:flex lg:gap-8">
        <aside class="hidden lg:block lg:w-72">
          <nav class="sticky top-8 rounded-xl border border-slate-200/60 bg-white/60 p-4 shadow-sm backdrop-blur dark:border-slate-800/60 dark:bg-slate-900/40" aria-label="Table of contents">
            <h2 class="mb-3 text-xs font-semibold uppercase tracking-wider text-slate-500 dark:text-slate-400">On this page</h2>
            <ol class="space-y-1 text-sm">
              <li><a href="#introduction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Introduction</a></li>
              <li><a href="#async-programming-basics" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Async Programming Basics</a></li>
              <li><a href="#spring-async-annotation" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Spring @Async Annotation</a></li>
              <li><a href="#completablefuture" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">CompletableFuture</a></li>
              <li><a href="#thread-pools" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Thread Pools</a></li>
              <li><a href="#kafka-introduction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Kafka Introduction</a></li>
              <li><a href="#kafka-setup" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Kafka Setup</a></li>
              <li><a href="#producing-messages" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Producing Messages</a></li>
              <li><a href="#consuming-messages" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Consuming Messages</a></li>
              <li><a href="#summary" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Summary</a></li>
              <li><a href="#programming-challenge" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Programming Challenge</a></li>
            </ol>
          </nav>
        </aside>
        <div class="min-w-0 flex-1">
          <div class="mb-6">
            <a href="../index.html" class="inline-block text-sm text-indigo-600 hover:underline dark:text-indigo-400">‚Üê Back to Concepts</a>
          </div>
          <header class="mx-auto max-w-3xl text-center">
            <h1 class="text-center text-3xl font-extrabold tracking-tight sm:text-4xl">Lesson 23: Spring Boot Async Programming and Messaging with Kafka Part 1</h1>
            <p class="mt-2 text-slate-600 dark:text-slate-300">Master asynchronous programming in Spring Boot and get started with Apache Kafka: async processing, Kafka introduction, setup, and producing/consuming messages for scalable applications.</p>
          </header>

          <section id="introduction" class="prose prose-slate mt-6 max-w-none dark:prose-invert">
            <h2>Introduction</h2>
            <p>Modern applications need to handle multiple tasks simultaneously without making users wait for slow operations to complete. Asynchronous programming allows your application to start a task and continue with other work while that task runs in the background, much like how you can start your washing machine and continue with other activities while it runs. Apache Kafka takes this concept further by enabling different parts of your application, or even different applications, to communicate through messages without being directly connected. This lesson introduces you to Spring Boot's asynchronous programming capabilities using @Async and CompletableFuture, then explores Apache Kafka as a powerful messaging system for building scalable, event-driven applications. You'll learn how to set up Kafka, produce messages to topics, and consume those messages in your Spring Boot applications. These skills are essential for building responsive applications that can handle high loads and complex workflows efficiently.</p>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="async-programming-basics" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Async Programming Basics</h2>
            <h3>Definition</h3>
            <p>Asynchronous programming allows your application to execute operations without blocking the main thread, enabling better resource utilization and improved user experience. Instead of waiting for a slow operation to complete before moving to the next task, async programming starts the operation and immediately returns control to the caller. The operation continues running in the background, and the result is made available when the operation completes. This approach is particularly valuable for I/O operations like database queries, web service calls, file operations, and email sending that typically involve waiting for external systems.</p>

            <h3>Analogy</h3>
            <p>Asynchronous programming is like being an efficient restaurant manager during a busy dinner rush. Instead of taking an order, walking to the kitchen, waiting for the food to be prepared, bringing it back to the table, and only then taking the next order (synchronous approach), a good manager takes the first order, gives it to the kitchen, immediately moves to take the second order while the first meal is being prepared, then the third order, and so on. The manager keeps track of all orders and delivers meals as they become ready, without ever standing idle waiting for the kitchen. This way, the restaurant serves many more customers in the same amount of time, and customers don't have to wait as long because multiple orders are being processed simultaneously. The manager (main thread) stays responsive and productive, while the kitchen staff (background threads) handle the time-consuming food preparation tasks.</p>

            <h3>Examples</h3>
            <p><strong>Synchronous vs Asynchronous email sending:</strong></p>
            <pre><code class="language-java">// Synchronous - blocks until email is sent
public void registerUser(User user) {
    userRepository.save(user);
    emailService.sendWelcomeEmail(user); // Waits here
    logger.info("User registered: " + user.getEmail());
}
</code></pre>

            <pre><code class="language-java">// Asynchronous - continues immediately
public void registerUser(User user) {
    userRepository.save(user);
    emailService.sendWelcomeEmailAsync(user); // Doesn't wait
    logger.info("User registered: " + user.getEmail());
}
</code></pre>

            <p><strong>Async method with @Async annotation:</strong></p>
            <pre><code class="language-java">@Service
public class EmailService {

    @Async
    public CompletableFuture<Void> sendWelcomeEmailAsync(User user) {
        // Simulating email sending delay
        Thread.sleep(2000);
        emailClient.send(user.getEmail(), "Welcome!");
        return CompletableFuture.completedFuture(null);
    }
}
</code></pre>

            <p><strong>Benefits of async processing:</strong></p>
            <pre><code class="language-java">// Multiple async operations can run simultaneously
CompletableFuture<Void> emailTask = emailService.sendEmail(user);
CompletableFuture<Void> smsTask = smsService.sendSms(user);
CompletableFuture<Void> auditTask = auditService.logRegistration(user);

// All three operations run concurrently
CompletableFuture.allOf(emailTask, smsTask, auditTask).join();
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="spring-async-annotation" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Spring @Async Annotation</h2>
            <h3>Definition</h3>
            <p>The @Async annotation in Spring Boot enables methods to run asynchronously in separate threads, allowing the calling thread to continue execution without waiting for the method to complete. When you annotate a method with @Async, Spring creates a proxy that intercepts the method call and executes it in a background thread from a thread pool. The method can return void for fire-and-forget operations, or CompletableFuture for operations where you need to handle the result later. To use @Async, you must enable async processing with @EnableAsync in your configuration class.</p>

            <h3>Analogy</h3>
            <p>Using @Async is like having a team of assistants in an office who can handle tasks independently. When you (the main thread) need to send a document for review, instead of walking to the reviewer's office, waiting for them to read it, and bringing back their feedback (synchronous), you simply hand the document to one of your assistants (@Async method) and continue with your other work. The assistant takes the document to the reviewer, waits for the feedback, and either files it away (void return) or brings it back to your desk when you're ready to look at it (CompletableFuture return). You can give multiple documents to different assistants simultaneously, and each assistant works independently. The office manager (@EnableAsync) coordinates this system and ensures there are enough assistants available to handle the workload efficiently.</p>

            <h3>Examples</h3>
            <p><strong>Enable async processing:</strong></p>
            <pre><code class="language-java">@Configuration
@EnableAsync
public class AsyncConfig {
    // Async processing is now enabled
}
</code></pre>

            <p><strong>Simple async method (fire-and-forget):</strong></p>
            <pre><code class="language-java">@Service
public class NotificationService {

    @Async
    public void sendNotification(String message, String recipient) {
        // This runs in a background thread
        logger.info("Sending notification to: " + recipient);
        notificationClient.send(message, recipient);
        logger.info("Notification sent successfully");
    }
}
</code></pre>

            <p><strong>Async method returning CompletableFuture:</strong></p>
            <pre><code class="language-java">@Service
public class UserService {

    @Async
    public CompletableFuture<User> findUserAsync(Long userId) {
        User user = userRepository.findById(userId);
        return CompletableFuture.completedFuture(user);
    }
}
</code></pre>

            <p><strong>Using async methods in controller:</strong></p>
            <pre><code class="language-java">@RestController
public class UserController {

    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User savedUser = userService.save(user);

        // These run asynchronously - doesn't block response
        notificationService.sendNotification("Welcome!", user.getEmail());
        auditService.logUserCreation(user.getId());

        return ResponseEntity.ok(savedUser);
    }
}
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="completablefuture" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>CompletableFuture</h2>
            <h3>Definition</h3>
            <p>CompletableFuture is Java's powerful API for asynchronous programming that allows you to write non-blocking code, chain operations, combine multiple async operations, and handle results or exceptions when they become available. Unlike simple async methods that you fire and forget, CompletableFuture gives you control over the async operation's lifecycle. You can chain transformations, combine multiple futures, add callbacks for completion or error handling, and even set timeouts. CompletableFuture bridges the gap between starting an async operation and processing its result, making complex async workflows manageable and readable.</p>

            <h3>Analogy</h3>
            <p>CompletableFuture is like having a smart courier service with tracking and automated workflows. When you send a package (start an async operation), you get a tracking number (CompletableFuture) that you can use to monitor the delivery status. You can set up automated actions: when the package is delivered, automatically send a thank-you email to the recipient; if delivery fails, automatically schedule a retry; when multiple packages arrive at the same destination, combine them into one notification. You can also chain deliveries: when Package A is delivered, automatically send Package B, and when Package B arrives, send Package C. The courier service handles all the complexity of timing, routing, and coordination, while you just define what should happen when each step completes. You can even set up conditional logic: if the package arrives before noon, send it to the office; if it arrives later, send it to the home address.</p>

            <h3>Examples</h3>
            <p><strong>Creating and completing a CompletableFuture:</strong></p>
            <pre><code class="language-java">// Create a future that completes immediately
CompletableFuture<String> future = CompletableFuture.completedFuture("Hello");

// Create a future with async computation
CompletableFuture<String> asyncFuture = CompletableFuture.supplyAsync(() -> {
    return "Computed result";
});
</code></pre>

            <p><strong>Chaining operations with thenApply:</strong></p>
            <pre><code class="language-java">CompletableFuture<String> result = userService.findUserAsync(1L)
    .thenApply(user -> user.getEmail())
    .thenApply(email -> email.toUpperCase())
    .thenApply(email -> "Welcome " + email);
</code></pre>

            <p><strong>Combining multiple futures:</strong></p>
            <pre><code class="language-java">CompletableFuture<User> userFuture = userService.findUserAsync(1L);
CompletableFuture<List<Order>> ordersFuture = orderService.findOrdersAsync(1L);

CompletableFuture<String> combined = userFuture.thenCombine(ordersFuture,
    (user, orders) -> user.getName() + " has " + orders.size() + " orders");
</code></pre>

            <p><strong>Error handling with CompletableFuture:</strong></p>
            <pre><code class="language-java">CompletableFuture<String> future = userService.findUserAsync(1L)
    .thenApply(user -> user.getEmail())
    .exceptionally(throwable -> {
        logger.error("Failed to get user email", throwable);
        return "default@example.com";
    });
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="thread-pools" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Thread Pools</h2>
            <h3>Definition</h3>
            <p>Thread pools manage a collection of reusable threads that execute async tasks, providing better resource management and performance control compared to creating new threads for each task. Spring Boot provides default thread pools for @Async methods, but you can customize them to optimize for your specific workload. Thread pool configuration includes core pool size (minimum threads always available), maximum pool size (maximum threads that can be created), queue capacity (how many tasks can wait), and keep-alive time (how long idle threads stay alive). Proper thread pool configuration prevents resource exhaustion and ensures optimal performance under different load conditions.</p>

            <h3>Analogy</h3>
            <p>A thread pool is like the staff management system at a busy restaurant. Instead of hiring a new waiter every time a customer arrives and firing them when the customer leaves (creating new threads), the restaurant maintains a core team of waiters who are always on duty (core pool size) and can hire additional temporary staff during peak hours up to a maximum capacity (maximum pool size). When it's busy, customer requests wait in a queue to be served by the next available waiter (task queue). During slow periods, some temporary staff might be sent home after a certain idle time (keep-alive time), but the core staff always remains. This system ensures consistent service, manages labor costs, and handles varying customer loads efficiently without the overhead of constantly hiring and training new staff.</p>

            <h3>Examples</h3>
            <p><strong>Custom thread pool configuration:</strong></p>
            <pre><code class="language-java">@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Bean(name = "emailExecutor")
    public Executor emailExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(100);
        executor.setThreadNamePrefix("email-");
        executor.initialize();
        return executor;
    }
}
</code></pre>

            <p><strong>Using specific thread pool:</strong></p>
            <pre><code class="language-java">@Service
public class EmailService {

    @Async("emailExecutor")
    public CompletableFuture<Void> sendEmailAsync(String to, String message) {
        // Uses the emailExecutor thread pool
        emailClient.send(to, message);
        return CompletableFuture.completedFuture(null);
    }
}
</code></pre>

            <p><strong>Multiple thread pools for different tasks:</strong></p>
            <pre><code class="language-java">@Bean(name = "reportExecutor")
public Executor reportExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(2);  // CPU-intensive tasks
    executor.setMaxPoolSize(4);
    executor.setQueueCapacity(50);
    return executor;
}

@Async("reportExecutor")
public CompletableFuture<Report> generateReportAsync(Long userId) {
    return CompletableFuture.completedFuture(reportService.generate(userId));
}
</code></pre>

            <p><strong>Thread pool monitoring:</strong></p>
            <pre><code class="language-java">@Component
public class ThreadPoolMonitor {

    @Autowired
    @Qualifier("emailExecutor")
    private ThreadPoolTaskExecutor emailExecutor;

    @Scheduled(fixedRate = 30000)
    public void monitorThreadPool() {
        logger.info("Email executor - Active: {}, Pool size: {}, Queue size: {}",
            emailExecutor.getActiveCount(),
            emailExecutor.getPoolSize(),
            emailExecutor.getQueueSize());
    }
}
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="kafka-introduction" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Kafka Introduction</h2>
            <h3>Definition</h3>
            <p>Apache Kafka is a distributed streaming platform that allows applications to publish and subscribe to streams of messages in a fault-tolerant, scalable way. Kafka organizes messages into topics (categories), which are split into partitions for parallel processing and replicated across multiple servers for reliability. Producers send messages to topics, while consumers read messages from topics, enabling loose coupling between different parts of your system. Kafka excels at handling high-throughput, real-time data streams and is commonly used for event sourcing, log aggregation, metrics collection, and building event-driven microservices architectures.</p>

            <h3>Analogy</h3>
            <p>Kafka is like a massive, organized newsstand system in a busy city that handles news distribution for the entire metropolitan area. The newsstand has different sections (topics) for different types of news: sports, business, local events, weather, and entertainment. Each section has multiple identical newsstands (partitions) distributed across the city for faster access and redundancy. Newspapers and magazines (producers) deliver their stories to the appropriate sections, while readers (consumers) can subscribe to specific sections they're interested in. The system keeps copies of each publication at multiple locations (replication) so that if one newsstand is damaged, the news is still available elsewhere. Readers can start reading from any point in the publication history, and new readers can catch up by reading older issues. The system can handle millions of readers and thousands of publications simultaneously, making sure everyone gets the news they want when they want it.</p>

            <h3>Examples</h3>
            <p><strong>Kafka key concepts:</strong></p>
            <pre><code class="language-java">// Topic: A category of messages (like "user-events")
// Partition: A subdivision of a topic for parallel processing
// Producer: Application that sends messages to topics
// Consumer: Application that reads messages from topics
// Consumer Group: Multiple consumers working together
</code></pre>

            <p><strong>Common Kafka use cases:</strong></p>
            <pre><code class="language-java">// Event-driven architecture
userService.createUser(user);
// Publishes "user-created" event to Kafka

// Other services can react to this event:
// - Email service sends welcome email
// - Analytics service tracks user registration
// - Recommendation service prepares personalized content
</code></pre>

            <p><strong>Kafka benefits for microservices:</strong></p>
            <pre><code class="language-java">// Loose coupling - services don't need to know about each other
// Scalability - can handle millions of messages per second
// Reliability - messages are persisted and replicated
// Real-time processing - low latency message delivery
// Event sourcing - complete audit trail of all events
</code></pre>

            <p><strong>Kafka vs traditional messaging:</strong></p>
            <pre><code class="language-java">// Traditional: Direct service calls (tight coupling)
orderService.createOrder(order);
emailService.sendConfirmation(order); // Direct dependency

// Kafka: Event-driven (loose coupling)
orderService.createOrder(order);
// Publishes event, doesn't know who consumes it
kafkaTemplate.send("order-events", orderCreatedEvent);
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="kafka-setup" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Kafka Setup</h2>
            <h3>Definition</h3>
            <p>Setting up Kafka with Spring Boot involves adding the necessary dependencies, configuring connection properties, and creating the required beans for producers and consumers. Spring Boot provides excellent integration with Kafka through Spring Kafka, which simplifies configuration and provides useful abstractions like KafkaTemplate for sending messages and @KafkaListener for consuming messages. The setup includes configuring bootstrap servers (Kafka broker addresses), serializers for converting objects to bytes, deserializers for converting bytes back to objects, and various other properties for security, error handling, and performance tuning.</p>

            <h3>Analogy</h3>
            <p>Setting up Kafka is like establishing a comprehensive postal system for a new city. First, you need to set up the post office infrastructure (Kafka brokers) with multiple locations throughout the city for reliability and accessibility. Then you configure the addressing system (topics and partitions) so mail can be properly sorted and delivered. You establish protocols for how letters should be packaged (serializers) and how they should be unpacked when delivered (deserializers). You set up mail trucks (producers) with routes to collect and deliver mail to the post offices, and mail carriers (consumers) who pick up mail from specific post office boxes and deliver it to the intended recipients. You also establish security procedures, backup systems, and quality standards to ensure mail is delivered reliably and securely throughout the city.</p>

            <h3>Examples</h3>
            <p><strong>Maven dependency for Spring Kafka:</strong></p>
            <pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

            <p><strong>Basic Kafka configuration:</strong></p>
            <pre><code class="language-properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.group-id=my-app-group
</code></pre>

            <p><strong>Kafka configuration class:</strong></p>
            <pre><code class="language-java">@Configuration
@EnableKafka
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public KafkaTemplate&lt;String, String&gt; kafkaTemplate() {
        return new KafkaTemplate&lt;&gt;(producerFactory());
    }

    @Bean
    public ProducerFactory&lt;String, String&gt; producerFactory() {
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        return new DefaultKafkaProducerFactory&lt;&gt;(props);
    }
}
</code></pre>

            <p><strong>Docker setup for local development:</strong></p>
            <pre><code class="language-yaml">version: '3.8'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181

  kafka:
    image: confluentinc/cp-kafka:latest
    depends_on:
      - zookeeper
    ports:
      - "9092:9092"
    environment:
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="producing-messages" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Producing Messages</h2>
            <h3>Definition</h3>
            <p>Producing messages in Kafka involves sending data to specific topics using a KafkaTemplate, which is Spring's abstraction for interacting with Kafka producers. Producers can send messages synchronously (waiting for confirmation) or asynchronously (fire-and-forget or with callbacks). Messages consist of a key (optional, used for partitioning), a value (the actual data), and headers (metadata). Kafka producers automatically handle partitioning, batching, compression, and retry logic. You can send simple strings, JSON objects, or custom serialized data, and Spring Boot makes it easy to integrate message production into your business logic.</p>
            <h3>Analogy</h3>
            <p>Producing Kafka messages is like being a journalist who submits articles to different newspaper sections. When you finish writing an article (create a message), you decide which section it belongs to (choose a topic) - sports, business, or local news. You can either hand-deliver the article to the editor and wait for confirmation that it will be published (synchronous send), or drop it in the editor's inbox and continue with your next article (asynchronous send). Some articles are time-sensitive breaking news that must be published immediately (priority messages), while others are feature stories that can wait. The newspaper's publishing system (Kafka) automatically distributes your article to the appropriate printing facilities (partitions) based on the topic and ensures it reaches all subscribers who are interested in that section. You can also include notes for the editor (headers) with special instructions about how the article should be handled.</p>

            <h3>Examples</h3>
            <p><strong>Simple message production:</strong></p>
            <pre><code class="language-java">@Service
public class EventPublisher {

    @Autowired
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    public void publishUserEvent(String userId, String event) {
        kafkaTemplate.send("user-events", userId, event);
    }
}
</code></pre>

            <p><strong>Async message production with callback:</strong></p>
            <pre><code class="language-java">public void publishOrderEvent(Order order) {
    String orderJson = objectMapper.writeValueAsString(order);

    kafkaTemplate.send("order-events", order.getId().toString(), orderJson)
        .addCallback(
            result -> logger.info("Order event sent successfully: {}", order.getId()),
            failure -> logger.error("Failed to send order event: {}", order.getId(), failure)
        );
}
</code></pre>

            <p><strong>Publishing domain events from service:</strong></p>
            <pre><code class="language-java">@Service
public class UserService {

    @Autowired
    private EventPublisher eventPublisher;

    public User createUser(User user) {
        User savedUser = userRepository.save(user);

        // Publish event for other services to react
        UserCreatedEvent event = new UserCreatedEvent(
            savedUser.getId(),
            savedUser.getEmail(),
            Instant.now()
        );

        eventPublisher.publishUserCreated(event);
        return savedUser;
    }
}
</code></pre>

            <p><strong>Transactional message production:</strong></p>
            <pre><code class="language-java">@Transactional
public void processOrderWithEvents(Order order) {
    // Save to database
    orderRepository.save(order);

    // Send event - only if database transaction succeeds
    kafkaTemplate.send("order-events", orderCreatedEvent);

    // If any exception occurs, both database and Kafka operations rollback
}
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="consuming-messages" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Consuming Messages</h2>
            <h3>Definition</h3>
            <p>Consuming messages in Kafka involves reading data from topics using consumers that can process messages individually or in batches. Spring Boot simplifies consumption with the @KafkaListener annotation, which automatically handles the complexities of consumer group management, offset tracking, and error handling. Consumers can be part of consumer groups where multiple instances share the workload by processing different partitions. Key concepts include offset management (tracking which messages have been processed), consumer group coordination (distributing partitions among group members), and error handling strategies for dealing with processing failures. Consumers can process messages synchronously or asynchronously depending on your use case.</p>

            <h3>Analogy</h3>
            <p>Consuming Kafka messages is like having a team of specialized librarians who monitor different sections of a massive library and process new books as they arrive. Each librarian (consumer) is responsible for monitoring specific shelves (partitions) within their assigned sections (topics). When new books arrive, the librarians follow their specific procedures: the history librarian catalogs historical books, the science librarian processes scientific publications, and the fiction librarian handles novels. If there are multiple librarians working on the same section (consumer group), they divide the shelves among themselves so no book is processed twice. Each librarian keeps a bookmark (offset) to track exactly where they left off, so if they take a break or if a new librarian joins the team, work can continue seamlessly from the right position. If a librarian encounters a damaged book (processing error), they follow established procedures to either repair it, set it aside for special handling, or escalate to a supervisor.</p>

            <h3>Examples</h3>
            <p><strong>Simple message consumer:</strong></p>
            <pre><code class="language-java">@Component
public class UserEventConsumer {

    @KafkaListener(topics = "user-events", groupId = "user-service-group")
    public void handleUserEvent(String message) {
        logger.info("Received user event: {}", message);
        // Process the event
        processUserEvent(message);
    }
}
</code></pre>

            <p><strong>Consumer with key and value:</strong></p>
            <pre><code class="language-java">@KafkaListener(topics = "order-events", groupId = "notification-service")
public void handleOrderEvent(
    @Payload String orderData,
    @Header(KafkaHeaders.RECEIVED_MESSAGE_KEY) String orderId) {

    logger.info("Processing order {} with data: {}", orderId, orderData);

    Order order = objectMapper.readValue(orderData, Order.class);
    emailService.sendOrderConfirmation(order);
}
</code></pre>

            <p><strong>Batch message consumption:</strong></p>
            <pre><code class="language-java">@KafkaListener(topics = "analytics-events",
               groupId = "analytics-batch-processor",
               containerFactory = "batchListenerContainerFactory")
public void handleAnalyticsBatch(List&lt;String&gt; events) {
    logger.info("Processing batch of {} analytics events", events.size());

    // Process events in batch for better performance
    analyticsService.processBatch(events);
}
</code></pre>

            <p><strong>Error handling in consumers:</strong></p>
            <pre><code class="language-java">@KafkaListener(topics = "payment-events", groupId = "payment-processor")
public void handlePaymentEvent(String paymentData) {
    try {
        PaymentEvent event = objectMapper.readValue(paymentData, PaymentEvent.class);
        paymentService.processPayment(event);
    } catch (Exception e) {
        logger.error("Failed to process payment event: {}", paymentData, e);
        // Send to dead letter topic or retry queue
        kafkaTemplate.send("payment-events-dlq", paymentData);
    }
}
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="summary" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Summary</h2>
            <p>You've now learned the fundamentals of asynchronous programming in Spring Boot and messaging with Apache Kafka. Async programming with @Async and CompletableFuture allows your applications to handle multiple tasks simultaneously without blocking, improving performance and user experience. Thread pools provide efficient resource management for concurrent operations. Apache Kafka enables building scalable, event-driven architectures where services communicate through messages rather than direct calls, promoting loose coupling and resilience. You understand how to set up Kafka, produce messages to topics, and consume messages using Spring Boot's excellent integration support. These skills form the foundation for building reactive, scalable applications that can handle high loads and complex workflows efficiently. In the next lesson, you'll explore advanced Kafka patterns including stream processing, exactly-once semantics, and building robust event-driven systems that can handle real-world complexity.</p>
          </section>

          <section id="programming-challenge" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Programming Challenge</h2>
            <div class="rounded-lg border border-slate-200 bg-slate-50 p-6 dark:border-slate-700 dark:bg-slate-800">
              <h3 class="mt-0">Challenge: Build an Async E-commerce Order Processing System</h3>
              <p><strong>Task:</strong> Create an order processing system that demonstrates async programming and Kafka messaging patterns.</p>

              <p><strong>Requirements:</strong></p>
              <ol>
                <li><strong>Order Service:</strong> Creates orders and publishes events to Kafka</li>
                <li><strong>Inventory Service:</strong> Consumes order events and checks/reserves inventory</li>
                <li><strong>Payment Service:</strong> Processes payments asynchronously</li>
                <li><strong>Email Service:</strong> Sends confirmation emails using @Async</li>
                <li><strong>Analytics Service:</strong> Consumes events for reporting (batch processing)</li>
              </ol>

              <p><strong>Async features to implement:</strong></p>
              <ul>
                <li>Use @Async for email sending and audit logging</li>
                <li>Implement CompletableFuture for payment processing</li>
                <li>Configure custom thread pools for different tasks</li>
                <li>Create async methods that return CompletableFuture</li>
                <li>Chain multiple async operations together</li>
              </ul>

              <p><strong>Kafka integration:</strong></p>
              <ul>
                <li>Set up Kafka with Docker Compose</li>
                <li>Create topics: order-events, inventory-events, payment-events</li>
                <li>Implement producers using KafkaTemplate</li>
                <li>Create consumers with @KafkaListener</li>
                <li>Handle both individual and batch message processing</li>
                <li>Add error handling and dead letter topics</li>
              </ul>

              <p><strong>Workflow:</strong></p>
              <ol>
                <li>User creates order ‚Üí Order Service saves and publishes order-created event</li>
                <li>Inventory Service consumes event ‚Üí checks stock ‚Üí publishes inventory-reserved event</li>
                <li>Payment Service consumes event ‚Üí processes payment asynchronously ‚Üí publishes payment-completed event</li>
                <li>Email Service consumes payment event ‚Üí sends confirmation email asynchronously</li>
                <li>Analytics Service consumes all events ‚Üí processes in batches for reporting</li>
              </ol>

              <p><strong>Learning Goals:</strong> Practice async programming patterns, understand Kafka producer/consumer implementation, learn event-driven architecture design, and gain experience with Spring Boot's async and messaging capabilities.</p>
            </div>
          </section>

          <nav class="mt-12 flex items-center justify-between border-t border-slate-200/60 pt-6 dark:border-slate-800/60">
            <a href="lesson-22.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Previous</a>
            <a href="lesson-24.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Next</a>
          </nav>
        </div>
      </div>
    </main>

    <footer class="border-t border-slate-200/60 py-10 text-center text-sm text-slate-500 dark:border-slate-800/60 dark:text-slate-400">
      <div class="mx-auto max-w-7xl px-6">
        <p>¬© 2025 wassim lagnaoui. All rights reserved.</p>
      </div>
    </footer>

    <script>
      document.getElementById('themeToggle').addEventListener('click', function(){
        const r=document.documentElement; const d=r.classList.toggle('dark');
        try{localStorage.setItem('theme', d?'dark':'light');}catch{}
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      if (window.Prism && Prism.plugins && Prism.plugins.autoloader) {
        Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1/components/';
        Prism.highlightAll();
      }
    </script>
  </body>
</html>


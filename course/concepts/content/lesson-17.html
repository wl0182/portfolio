<!doctype html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lesson 17 - Spring Boot Production Monitoring and Caching</title>
    <meta name="description" content="Master Spring Boot Actuator monitoring and caching: health checks, metrics, endpoints, cache strategies, and performance optimization for production applications." />
    <script>(function(){try{const t=localStorage.getItem('theme');const d=matchMedia('(prefers-color-scheme: dark)').matches;if(t==='dark'||(!t&&d))document.documentElement.classList.add('dark');}catch{}})();</script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ sans:["Inter var","Inter","ui-sans-serif","system-ui","-apple-system","Segoe UI","Roboto","Helvetica","Arial","Noto Sans","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"] } } } };
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css" />
    <link rel="stylesheet" href="../../../tutorials/tutorials.css" />
  </head>
  <body class="bg-white text-slate-800 antialiased dark:bg-slate-950 dark:text-slate-100">
    <div aria-hidden="true" class="pointer-events-none fixed inset-0 -z-10"><div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 via-fuchsia-500/10 to-emerald-500/10 blur-2xl"></div></div>

    <header class="z-20 backdrop-blur supports-[backdrop-filter]:bg-white/60 supports-[backdrop-filter]:dark:bg-slate-950/40 border-b border-slate-200/60 dark:border-slate-800/60">
      <div class="mx-auto flex max-w-7xl items-center justify-between gap-4 px-6 py-4">
        <a href="../../../" class="group inline-flex items-center gap-3">
          <span class="grid h-9 w-9 place-items-center rounded-lg bg-indigo-600 text-white shadow-md shadow-indigo-600/30">WL</span>
          <div class="leading-tight">
            <div class="text-sm text-slate-500 dark:text-slate-400">Java Full Stack Developer</div>
            <div class="font-semibold">Wassim Lagnaoui</div>
          </div>
        </a>
        <nav class="hidden items-center gap-6 md:flex">
          <a href="../../../#about" class="hover:text-indigo-600 dark:hover:text-indigo-400">About</a>
          <a href="../../../blog/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Blog</a>
          <a href="../../../#skills" class="hover:text-indigo-600 dark:hover:text-indigo-400">Skills</a>
          <a href="../../../projects/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Projects</a>
          <a href="../../../tutorials/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Tutorials</a>
          <a href="../../" class="text-indigo-600 dark:text-indigo-400">Courses</a>
        </nav>
        <button id="themeToggle" class="inline-flex items-center justify-center rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800" aria-label="Toggle theme">
          <svg class="h-5 w-5 dark:hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v2m0 14v2M5.64 5.64l1.41 1.41M16.95 16.95l1.41 1.41M3 12h2m14 0h2M5.64 18.36l1.41-1.41M16.95 7.05l1.41-1.41"/><circle cx="12" cy="12" r="4"/></svg>
          <svg class="hidden h-5 w-5 dark:block" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        </button>
      </div>
    </header>

    <main class="mx-auto max-w-7xl px-6 py-10">
      <div class="lg:flex lg:gap-8">
        <aside class="hidden lg:block lg:w-72">
          <nav class="sticky top-8 rounded-xl border border-slate-200/60 bg-white/60 p-4 shadow-sm backdrop-blur dark:border-slate-800/60 dark:bg-slate-900/40" aria-label="Table of contents">
            <h2 class="mb-3 text-xs font-semibold uppercase tracking-wider text-slate-500 dark:text-slate-400">On this page</h2>
            <ol class="space-y-1 text-sm">
              <li><a href="#introduction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Introduction</a></li>
              <li><a href="#understanding-actuator" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Understanding Actuator</a></li>
              <li><a href="#health-checks" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Health Checks</a></li>
              <li><a href="#application-info" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Application Info</a></li>
              <li><a href="#metrics-monitoring" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Metrics Monitoring</a></li>
              <li><a href="#custom-endpoints" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Custom Endpoints</a></li>
              <li><a href="#understanding-caching" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Understanding Caching</a></li>
              <li><a href="#spring-cache-abstraction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Spring Cache Abstraction</a></li>
              <li><a href="#cache-annotations" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Annotations</a></li>
              <li><a href="#cache-providers" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Providers</a></li>
              <li><a href="#cache-configuration" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Configuration</a></li>
              <li><a href="#monitoring-caching" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Monitoring & Caching</a></li>
              <li><a href="#production-best-practices" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Production Best Practices</a></li>
              <li><a href="#summary" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Summary</a></li>
              <li><a href="#programming-challenge" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Programming Challenge</a></li>
            </ol>
          </nav>
        </aside>
        <div class="min-w-0 flex-1">
          <div class="mb-6">
            <a href="../index.html" class="inline-block text-sm text-indigo-600 hover:underline dark:text-indigo-400">‚Üê Back to Concepts</a>
          </div>
          <header class="mx-auto max-w-3xl text-center">
            <h1 class="text-center text-3xl font-extrabold tracking-tight sm:text-4xl">Lesson 17: Spring Boot Production Monitoring and Caching</h1>
            <p class="mt-2 text-slate-600 dark:text-slate-300">Master Spring Boot Actuator for production monitoring and implement intelligent caching strategies to build high-performance, observable applications ready for enterprise environments.</p>
          </header>

          <section id="introduction" class="prose prose-slate mt-6 max-w-none dark:prose-invert">
            <h2>Introduction</h2>
            <p>Building production-ready applications requires two critical capabilities: comprehensive observability to understand how your application is performing, and intelligent caching to ensure it performs well under load. Spring Boot Actuator provides production-ready monitoring features that give you deep insights into application health, metrics, and operational status, while Spring's caching abstraction offers powerful performance optimization through intelligent data storage and retrieval. Think of monitoring as your application's vital signs monitor and caching as its short-term memory - monitoring tells you what's happening and whether everything is healthy, while caching helps your application respond faster by remembering frequently needed information. Together, these capabilities enable you to build applications that not only perform exceptionally well but also provide the observability needed to maintain that performance in production environments. This lesson teaches you to implement both comprehensive monitoring and effective caching strategies that work together to create resilient, high-performance applications.</p>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="understanding-actuator" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Understanding Actuator</h2>
            <h3>Definition</h3>
            <p>Spring Boot Actuator is a set of production-ready features that help you monitor and manage your application when it's running in production. It provides built-in endpoints for health checks, application metrics, environment details, and operational information. Actuator endpoints are automatically secured and can be customized or extended to meet specific monitoring requirements. These features give operations teams and developers the visibility they need to maintain healthy, performant applications in production environments.</p>

            <h3>Analogy</h3>
            <p>Think of Spring Boot Actuator like the comprehensive dashboard and diagnostic system in a modern car. Just as your car's dashboard shows you essential information like speed, fuel level, engine temperature, and oil pressure, Actuator provides a dashboard view of your application's vital signs. The car's diagnostic port allows mechanics to connect specialized tools to get detailed information about engine performance, sensor readings, and error codes - similarly, Actuator endpoints allow monitoring tools and operations teams to connect and get detailed insights into your application's performance, health status, and internal metrics.</p>

            <h3>Examples</h3>
            <p><strong>Adding Actuator dependency:</strong></p>
            <pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

            <p><strong>Basic Actuator configuration:</strong></p>
            <pre><code class="language-properties">management.endpoints.web.exposure.include=health,info,metrics,caches
management.endpoint.health.show-details=always
management.endpoints.web.base-path=/actuator</code></pre>

            <p><strong>Accessing health endpoint:</strong></p>
            <pre><code class="language-bash"># GET /actuator/health
{
  "status": "UP",
  "components": {
    "db": {"status": "UP"},
    "diskSpace": {"status": "UP"},
    "cacheManager": {"status": "UP"}
  }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="health-checks" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Health Checks</h2>
            <h3>Definition</h3>
            <p>Health checks provide a way to verify that your application and its dependencies are functioning correctly. Spring Boot Actuator includes built-in health indicators for databases, disk space, and other common components, and you can create custom health indicators for business-specific dependencies. Health checks return a status (UP, DOWN, OUT_OF_SERVICE) along with detailed information about what's being checked. Load balancers and monitoring systems use these endpoints to determine if an instance should receive traffic or needs attention.</p>

            <h3>Examples</h3>
            <p><strong>Custom health indicator for cache:</strong></p>
            <pre><code class="language-java">@Component
public class CacheHealthIndicator implements HealthIndicator {
    @Autowired
    private CacheManager cacheManager;

    public Health health() {
        try {
            Cache userCache = cacheManager.getCache("users");
            if (userCache != null) {
                return Health.up()
                    .withDetail("cache", "users")
                    .withDetail("status", "available")
                    .build();
            }
            return Health.down().withDetail("cache", "unavailable").build();
        } catch (Exception e) {
            return Health.down(e).build();
        }
    }
}</code></pre>

            <p><strong>Database and cache health check:</strong></p>
            <pre><code class="language-java">@Component
public class ApplicationHealthIndicator implements HealthIndicator {
    public Health health() {
        boolean dbHealth = checkDatabaseConnection();
        boolean cacheHealth = checkCacheAvailability();

        if (dbHealth && cacheHealth) {
            return Health.up()
                .withDetail("database", "connected")
                .withDetail("cache", "available")
                .build();
        }
        return Health.down()
            .withDetail("database", dbHealth ? "connected" : "disconnected")
            .withDetail("cache", cacheHealth ? "available" : "unavailable")
            .build();
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="application-info" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Application Info</h2>
            <h3>Definition</h3>
            <p>The info endpoint provides metadata about your application such as version numbers, build information, Git commit details, and custom application properties. This information helps operations teams understand exactly which version is deployed, when it was built, and what features it contains. You can customize the info endpoint to include cache configuration details, monitoring settings, and other operational information.</p>

            <h3>Examples</h3>
            <p><strong>Application info with cache details:</strong></p>
            <pre><code class="language-properties">info.app.name=E-commerce Platform
info.app.description=Product catalog with caching and monitoring
info.app.version=@project.version@
info.features.caching=enabled
info.features.monitoring=enabled</code></pre>

            <p><strong>Custom info contributor with cache information:</strong></p>
            <pre><code class="language-java">@Component
public class CacheInfoContributor implements InfoContributor {
    @Autowired
    private CacheManager cacheManager;

    public void contribute(Info.Builder builder) {
        Collection<String> cacheNames = cacheManager.getCacheNames();
        builder.withDetail("caching", Map.of(
            "provider", cacheManager.getClass().getSimpleName(),
            "caches", cacheNames,
            "count", cacheNames.size()
        ));
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="metrics-monitoring" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Metrics Monitoring</h2>
            <h3>Definition</h3>
            <p>Spring Boot Actuator provides comprehensive metrics about your application's performance, including JVM statistics, HTTP request metrics, database connection pool stats, and cache performance metrics. Built on Micrometer, it supports various monitoring systems like Prometheus, Grafana, and New Relic. Metrics help you understand application behavior over time, identify performance bottlenecks, track cache effectiveness, and set up alerting for abnormal conditions.</p>

            <h3>Examples</h3>
            <p><strong>Cache metrics monitoring:</strong></p>
            <pre><code class="language-java">@Component
public class CacheMetricsCollector {
    private final MeterRegistry meterRegistry;
    private final CacheManager cacheManager;

    public CacheMetricsCollector(MeterRegistry meterRegistry, CacheManager cacheManager) {
        this.meterRegistry = meterRegistry;
        this.cacheManager = cacheManager;

        // Register cache size gauges
        cacheManager.getCacheNames().forEach(cacheName -> {
            Gauge.builder("cache.size")
                 .tag("cache", cacheName)
                 .register(meterRegistry, this, metrics -> getCacheSize(cacheName));
        });
    }

    private double getCacheSize(String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        return cache != null ? cache.getNativeCache().size() : 0;
    }
}</code></pre>

            <p><strong>Custom business metrics with caching:</strong></p>
            <pre><code class="language-java">@Service
public class ProductService {
    private final Counter cacheHits;
    private final Counter cacheMisses;
    private final Timer queryTimer;

    public ProductService(MeterRegistry meterRegistry) {
        this.cacheHits = Counter.builder("cache.hits").tag("cache", "products").register(meterRegistry);
        this.cacheMisses = Counter.builder("cache.misses").tag("cache", "products").register(meterRegistry);
        this.queryTimer = Timer.builder("products.query.time").register(meterRegistry);
    }

    @Cacheable("products")
    public Product findProduct(Long id) {
        Timer.Sample sample = Timer.start();
        try {
            return productRepository.findById(id);
        } finally {
            sample.stop(queryTimer);
        }
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="custom-endpoints" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Custom Endpoints</h2>
            <h3>Definition</h3>
            <p>Custom Actuator endpoints allow you to expose application-specific operational information and controls. You can create endpoints for cache management, performance diagnostics, or business metrics. Custom endpoints follow the same security and exposure patterns as built-in endpoints, ensuring consistent access control and discoverability.</p>

            <h3>Examples</h3>
            <p><strong>Cache management endpoint:</strong></p>
            <pre><code class="language-java">@Endpoint(id = "cache-management")
@Component
public class CacheManagementEndpoint {
    @Autowired
    private CacheManager cacheManager;

    @ReadOperation
    public Map<String, Object> getCacheInfo() {
        Map<String, Object> cacheInfo = new HashMap<>();
        cacheManager.getCacheNames().forEach(name -> {
            Cache cache = cacheManager.getCache(name);
            cacheInfo.put(name, Map.of(
                "size", cache.getNativeCache().size(),
                "type", cache.getClass().getSimpleName()
            ));
        });
        return cacheInfo;
    }

    @WriteOperation
    public void clearCache(@Selector String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.clear();
        }
    }
}</code></pre>

            <p><strong>Performance monitoring endpoint:</strong></p>
            <pre><code class="language-java">@WebEndpoint(id = "performance")
@Component
public class PerformanceEndpoint {
    @ReadOperation
    public WebEndpointResponse<Map<String, Object>> getPerformanceStats() {
        Map<String, Object> stats = Map.of(
            "jvm-memory", getMemoryUsage(),
            "cache-stats", getCacheStatistics(),
            "request-metrics", getRequestMetrics()
        );
        return new WebEndpointResponse<>(stats, 200);
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="understanding-caching" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Understanding Caching</h2>
            <h3>Definition</h3>
            <p>Caching is a performance optimization technique that stores copies of frequently accessed data in fast-access storage to avoid repeated expensive operations. When data is requested, the cache is checked first; if found (cache hit), the cached data is returned immediately. If not found (cache miss), the expensive operation is performed, and the result is stored in the cache for future requests. Effective caching can reduce database load, improve response times, and enhance overall application scalability.</p>

            <h3>Analogy</h3>
            <p>Think of caching like the strategy a busy chef uses in a restaurant kitchen. Instead of going to the main storage room every time they need common ingredients like salt, pepper, or olive oil, the chef keeps frequently used items on the counter within arm's reach. When an order comes in for a dish that needs salt, the chef grabs it from the counter (cache hit) rather than walking to the storage room (database query). Occasionally, an ingredient runs out and the chef must restock from the main storage (cache miss), but this happens much less frequently than if they fetched every ingredient from storage for every dish.</p>

            <h3>Examples</h3>
            <p><strong>Without caching - repeated database queries:</strong></p>
            <pre><code class="language-java">public User getUser(Long id) {
    return userRepository.findById(id);  // Database query every time
}</code></pre>

            <p><strong>With caching - store results in memory:</strong></p>
            <pre><code class="language-java">@Cacheable("users")
public User getUser(Long id) {
    return userRepository.findById(id);  // Query once, cache result
}</code></pre>

            <p><strong>Cache performance comparison:</strong></p>
            <pre><code class="language-java">// Without cache: 200ms database query every time
// With cache: 200ms first time, 2ms subsequent requests
// 100x performance improvement for cached data!</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="spring-cache-abstraction" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Spring Cache Abstraction</h2>
            <h3>Definition</h3>
            <p>Spring's cache abstraction provides a unified programming model for caching that works with different cache providers without changing your code. The abstraction uses annotations to declare caching behavior, automatically handling cache operations like storing, retrieving, and evicting data. You can switch between cache providers (from simple HashMap to Redis clusters) by changing configuration, not code.</p>

            <h3>Examples</h3>
            <p><strong>Enable caching in Spring Boot:</strong></p>
            <pre><code class="language-java">@SpringBootApplication
@EnableCaching
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</code></pre>

            <p><strong>Cache configuration with monitoring:</strong></p>
            <pre><code class="language-java">@Configuration
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager manager = new CaffeineCacheManager("users", "products");
        manager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .recordStats()); // Enable statistics for monitoring
        return manager;
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-annotations" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Annotations</h2>
            <h3>Definition</h3>
            <p>Spring provides several cache annotations that declaratively define caching behavior. @Cacheable caches method results, @CacheEvict removes cached data, @CachePut updates cache entries, and @Caching combines multiple cache operations. These annotations use SpEL (Spring Expression Language) for dynamic cache keys and conditions.</p>

            <h3>Examples</h3>
            <p><strong>@Cacheable - cache method results:</strong></p>
            <pre><code class="language-java">@Cacheable(value = "users", key = "#id")
public User findUser(Long id) {
    return userRepository.findById(id);
}</code></pre>

            <p><strong>@CacheEvict - remove cached data:</strong></p>
            <pre><code class="language-java">@CacheEvict(value = "users", key = "#user.id")
public void updateUser(User user) {
    userRepository.save(user);
}</code></pre>

            <p><strong>@CachePut - update cache:</strong></p>
            <pre><code class="language-java">@CachePut(value = "users", key = "#result.id")
public User createUser(User user) {
    return userRepository.save(user);
}</code></pre>

            <p><strong>Conditional caching with monitoring:</strong></p>
            <pre><code class="language-java">@Cacheable(value = "products", condition = "#result != null", unless = "#result.price > 1000")
public Product findProduct(Long id) {
    Product product = productRepository.findById(id);
    // Log cache operation for monitoring
    logger.info("Product {} cached: {}", id, product != null);
    return product;
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-providers" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Providers</h2>
            <h3>Definition</h3>
            <p>Cache providers are the underlying storage mechanisms that actually hold cached data. Spring Boot supports various providers: ConcurrentHashMap for simple in-memory caching, Caffeine for high-performance local caching with advanced features, Redis for distributed caching across multiple servers, and Hazelcast for in-memory data grids. Each provider has different characteristics regarding performance, memory management, persistence, and distribution capabilities.</p>

            <h3>Examples</h3>
            <p><strong>Caffeine high-performance cache with monitoring:</strong></p>
            <pre><code class="language-java">@Bean
public CacheManager caffeineCacheManager() {
    CaffeineCacheManager manager = new CaffeineCacheManager();
    manager.setCaffeine(Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(10, TimeUnit.MINUTES)
        .recordStats()  // Enable statistics
        .removalListener((key, value, cause) -> {
            logger.info("Cache entry removed: key={}, cause={}", key, cause);
        }));
    return manager;
}</code></pre>

            <p><strong>Redis distributed cache configuration:</strong></p>
            <pre><code class="language-java">@Bean
public CacheManager redisCacheManager(RedisConnectionFactory factory) {
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofMinutes(30))
        .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));

    return RedisCacheManager.builder(factory)
        .cacheDefaults(config)
        .transactionAware()  // Support for monitoring transactions
        .build();
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-configuration" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Configuration</h2>
            <h3>Definition</h3>
            <p>Cache configuration defines how caches behave regarding size limits, expiration policies, eviction strategies, and serialization. Configuration includes setting maximum cache sizes, time-based expiration (TTL), access-based expiration, and cache warming strategies. Proper configuration ensures optimal memory usage, prevents cache growth from consuming all available memory, and maintains data freshness appropriate for your application's requirements.</p>

            <h3>Examples</h3>
            <p><strong>Environment-specific cache configuration:</strong></p>
            <pre><code class="language-properties"># application-dev.properties
spring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=5m

# application-prod.properties
spring.cache.caffeine.spec=maximumSize=10000,expireAfterWrite=30m
management.metrics.cache.instrument=true</code></pre>

            <p><strong>Multiple cache configurations:</strong></p>
            <pre><code class="language-java">@Bean
public CacheManager cacheManager() {
    CaffeineCacheManager manager = new CaffeineCacheManager();

    // Short-lived user sessions
    manager.registerCustomCache("user-sessions",
        Caffeine.newBuilder()
            .expireAfterAccess(30, TimeUnit.MINUTES)
            .recordStats()
            .build());

    // Long-lived reference data
    manager.registerCustomCache("reference-data",
        Caffeine.newBuilder()
            .expireAfterWrite(4, TimeUnit.HOURS)
            .maximumSize(5000)
            .recordStats()
            .build());

    return manager;
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="monitoring-caching" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Monitoring & Caching Integration</h2>
            <h3>Definition</h3>
            <p>Integrating monitoring with caching provides comprehensive visibility into cache performance, helping optimize cache strategies and troubleshoot performance issues. This includes tracking cache hit rates, monitoring eviction patterns, measuring cache-related response times, and alerting on cache health issues. Proper integration ensures that caching improvements are measurable and cache-related problems are quickly identified.</p>

            <h3>Examples</h3>
            <p><strong>Cache metrics endpoint:</strong></p>
            <pre><code class="language-java">@RestController
public class CacheMonitoringController {
    @Autowired
    private CacheManager cacheManager;

    @GetMapping("/actuator/cache-stats")
    public Map<String, Object> getCacheStatistics() {
        Map<String, Object> stats = new HashMap<>();

        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache.getNativeCache() instanceof com.github.benmanes.caffeine.cache.Cache) {
                com.github.benmanes.caffeine.cache.stats.CacheStats cacheStats =
                    ((com.github.benmanes.caffeine.cache.Cache<?, ?>) cache.getNativeCache()).stats();

                stats.put(cacheName, Map.of(
                    "hitRate", cacheStats.hitRate(),
                    "missCount", cacheStats.missCount(),
                    "evictionCount", cacheStats.evictionCount(),
                    "size", ((com.github.benmanes.caffeine.cache.Cache<?, ?>) cache.getNativeCache()).estimatedSize()
                ));
            }
        });

        return stats;
    }
}</code></pre>

            <p><strong>Cache health indicator:</strong></p>
            <pre><code class="language-java">@Component
public class CacheHealthIndicator implements HealthIndicator {
    @Autowired
    private CacheManager cacheManager;

    @Override
    public Health health() {
        Health.Builder builder = Health.up();

        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            try {
                // Test cache operation
                cache.get("health-check", () -> "OK");
                builder.withDetail(cacheName, "healthy");
            } catch (Exception e) {
                builder.down().withDetail(cacheName, "unhealthy: " + e.getMessage());
            }
        });

        return builder.build();
    }
}</code></pre>

            <p><strong>Cache warming with monitoring:</strong></p>
            <pre><code class="language-java">@Component
public class CacheWarmupService {
    private final Logger logger = LoggerFactory.getLogger(CacheWarmupService.class);
    private final MeterRegistry meterRegistry;

    @EventListener(ApplicationReadyEvent.class)
    public void warmupCaches() {
        Timer.Sample sample = Timer.start(meterRegistry);

        try {
            // Warm up popular products
            List<Product> popularProducts = productRepository.findTop100ByOrderBySalesDesc();
            popularProducts.forEach(product ->
                cacheManager.getCache("products").put(product.getId(), product));

            logger.info("Cache warmed with {} products", popularProducts.size());
            meterRegistry.counter("cache.warmup.success").increment();
        } catch (Exception e) {
            logger.error("Cache warmup failed", e);
            meterRegistry.counter("cache.warmup.failure").increment();
        } finally {
            sample.stop(Timer.builder("cache.warmup.duration").register(meterRegistry));
        }
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="production-best-practices" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Production Best Practices</h2>
            <h3>Definition</h3>
            <p>Production best practices for monitoring and caching involve securing endpoints, optimizing cache strategies, implementing proper alerting, and ensuring observability doesn't impact performance. This includes protecting sensitive monitoring endpoints, choosing appropriate cache eviction policies, setting up meaningful alerts, and monitoring the monitoring systems themselves to ensure reliability.</p>

            <h3>Examples</h3>
            <p><strong>Production monitoring security:</strong></p>
            <pre><code class="language-java">@Configuration
public class ActuatorSecurityConfig {
    @Bean
    public SecurityFilterChain actuatorSecurity(HttpSecurity http) throws Exception {
        return http.requestMatcher(EndpointRequest.toAnyEndpoint())
                  .authorizeHttpRequests(auth -> auth
                      .requestMatchers(EndpointRequest.to("health")).permitAll()
                      .requestMatchers(EndpointRequest.to("cache-stats")).hasRole("ADMIN")
                      .anyRequest().hasRole("ACTUATOR"))
                  .build();
    }
}</code></pre>

            <p><strong>Cache monitoring alerts:</strong></p>
            <pre><code class="language-java">@Component
public class CacheAlertingService {
    private final MeterRegistry meterRegistry;

    @EventListener
    @Async
    public void onCacheEviction(CacheEvictEvent event) {
        meterRegistry.counter("cache.evictions", "cache", event.getCacheName()).increment();

        // Alert if eviction rate is too high
        if (isEvictionRateHigh(event.getCacheName())) {
            alertingService.sendAlert(
                "High cache eviction rate detected for cache: " + event.getCacheName()
            );
        }
    }

    @Scheduled(fixedRate = 60000) // Every minute
    public void checkCacheHealth() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            double hitRate = getCacheHitRate(cache);

            if (hitRate < 0.8) { // Alert if hit rate drops below 80%
                alertingService.sendAlert(
                    String.format("Low cache hit rate (%.2f) for cache: %s", hitRate, cacheName)
                );
            }
        });
    }
}</code></pre>

            <p><strong>Production cache configuration:</strong></p>
            <pre><code class="language-yaml"># application-prod.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,cache-stats
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    cache:
      instrument: true
    export:
      prometheus:
        enabled: true

spring:
  cache:
    caffeine:
      spec: maximumSize=50000,expireAfterWrite=1h,recordStats=true</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="summary" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Summary</h2>
            <p>You've now mastered both Spring Boot Actuator monitoring and caching strategies, creating a powerful combination for building high-performance, observable applications. Actuator provides the comprehensive monitoring capabilities needed to understand application health and performance, while Spring's caching abstraction offers the tools to optimize that performance through intelligent data storage and retrieval. The integration of monitoring and caching creates a virtuous cycle: monitoring helps you identify what to cache and how well your caching strategies are working, while caching improves the performance metrics you're monitoring. You've learned to implement health checks, track meaningful metrics, create custom endpoints, configure various cache providers, and follow production best practices that ensure both performance and observability. These skills enable you to build applications that not only perform exceptionally well but also provide the visibility needed to maintain and improve that performance over time. Next, you'll explore comprehensive performance optimization techniques that build upon these monitoring and caching foundations.</p>
          </section>

          <section id="programming-challenge" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Programming Challenge</h2>
            <div class="rounded-lg border border-slate-200 bg-slate-50 p-6 dark:border-slate-700 dark:bg-slate-800">
              <h3 class="mt-0">Challenge: Comprehensive Monitoring and Caching E-commerce Platform</h3>
              <p><strong>Task:</strong> Build a Spring Boot e-commerce application with comprehensive monitoring capabilities and intelligent multi-level caching that demonstrates the integration of observability and performance optimization.</p>

              <p><strong>Requirements:</strong></p>
              <ol>
                <li>Create core entities and services:</li>
                <ul>
                  <li><code>Product</code>, <code>Category</code>, <code>Order</code>, <code>User</code> entities</li>
                  <li>Service layer with business logic for product catalog and order processing</li>
                  <li>REST endpoints for product search, user management, and order operations</li>
                </ul>
                <li>Implement comprehensive monitoring:</li>
                <ul>
                  <li>Custom health indicators for database, cache, and external services</li>
                  <li>Business metrics tracking (orders per minute, popular products, revenue)</li>
                  <li>Custom Actuator endpoints for business dashboard and cache management</li>
                  <li>Application events monitoring for startup, shutdown, and critical operations</li>
                </ul>
                <li>Design intelligent caching strategy:</li>
                <ul>
                  <li>L1 Cache: Individual products (1-hour TTL, high hit rate expected)</li>
                  <li>L2 Cache: Product categories and search results (30-min TTL)</li>
                  <li>L3 Cache: User profiles and preferences (4-hour TTL)</li>
                  <li>L4 Cache: Popular products with cache warming at startup</li>
                </ul>
                <li>Integrate monitoring with caching:</li>
                <ul>
                  <li>Cache hit/miss rate monitoring and alerting</li>
                  <li>Cache size and eviction pattern tracking</li>
                  <li>Performance comparison metrics (with/without cache)</li>
                  <li>Cache health indicators and automatic failover strategies</li>
                </ul>
                <li>Implement production features:</li>
                <ul>
                  <li>Structured logging with correlation IDs for request tracing</li>
                  <li>Security configuration for monitoring endpoints</li>
                  <li>Environment-specific cache and monitoring configurations</li>
                  <li>Graceful degradation when cache is unavailable</li>
                </ul>
                <li>Add management and operations capabilities:</li>
                <ul>
                  <li>Administrative endpoints for cache clearing and statistics</li>
                  <li>Scheduled cache refresh for critical data</li>
                  <li>Performance alerting based on response times and error rates</li>
                  <li>Prometheus metrics export for external monitoring systems</li>
                </ul>
              </ol>

              <p><strong>Bonus features:</strong></p>
              <ul>
                <li>Distributed caching with Redis and monitoring across multiple instances</li>
                <li>Cache warming based on user behavior patterns and popular search terms</li>
                <li>Dynamic cache configuration adjustment based on monitoring data</li>
                <li>Circuit breaker pattern with cache fallback and monitoring integration</li>
                <li>Custom cache eviction listeners with monitoring and alerting</li>
                <li>A/B testing framework for cache strategies with performance monitoring</li>
              </ul>

              <p><strong>Learning Goals:</strong> Practice integrating comprehensive monitoring with intelligent caching strategies, implementing production-ready observability features, creating meaningful business metrics, and building systems that provide both excellent performance and operational visibility for enterprise environments.</p>
            </div>
          </section>

          <nav class="mt-12 flex items-center justify-between border-t border-slate-200/60 pt-6 dark:border-slate-800/60">
            <a href="lesson-16.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Previous</a>
            <a href="lesson-18.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Next</a>
          </nav>
        </div>
      </div>
    </main>

    <footer class="border-t border-slate-200/60 py-10 text-center text-sm text-slate-500 dark:border-slate-800/60 dark:text-slate-400">
      <div class="mx-auto max-w-7xl px-6">
        <p>¬© 2025 wassim lagnaoui. All rights reserved.</p>
      </div>
    </footer>

    <script>
      document.getElementById('themeToggle').addEventListener('click', function(){
        const r=document.documentElement; const d=r.classList.toggle('dark');
        try{localStorage.setItem('theme', d?'dark':'light');}catch{}
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      if (window.Prism && Prism.plugins && Prism.plugins.autoloader) {
        Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1/components/';
        Prism.highlightAll();
      }
    </script>
  </body>
</html>

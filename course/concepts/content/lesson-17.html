<!doctype html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lesson 17 - Spring Boot Caching</title>
    <meta name="description" content="Master Spring Boot caching: cache abstraction, annotations, providers, configuration, and performance optimization strategies for high-performance applications." />
    <script>(function(){try{const t=localStorage.getItem('theme');const d=matchMedia('(prefers-color-scheme: dark)').matches;if(t==='dark'||(!t&&d))document.documentElement.classList.add('dark');}catch{}})();</script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ sans:["Inter var","Inter","ui-sans-serif","system-ui","-apple-system","Segoe UI","Roboto","Helvetica","Arial","Noto Sans","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"] } } } };
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css" />
    <link rel="stylesheet" href="../../../tutorials/tutorials.css" />
  </head>
  <body class="bg-white text-slate-800 antialiased dark:bg-slate-950 dark:text-slate-100">
    <div aria-hidden="true" class="pointer-events-none fixed inset-0 -z-10"><div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 via-fuchsia-500/10 to-emerald-500/10 blur-2xl"></div></div>

    <header class="z-20 backdrop-blur supports-[backdrop-filter]:bg-white/60 supports-[backdrop-filter]:dark:bg-slate-950/40 border-b border-slate-200/60 dark:border-slate-800/60">
      <div class="mx-auto flex max-w-7xl items-center justify-between gap-4 px-6 py-4">
        <a href="../../../" class="group inline-flex items-center gap-3">
          <span class="grid h-9 w-9 place-items-center rounded-lg bg-indigo-600 text-white shadow-md shadow-indigo-600/30">WL</span>
          <div class="leading-tight">
            <div class="text-sm text-slate-500 dark:text-slate-400">Java Full Stack Developer</div>
            <div class="font-semibold">Wassim Lagnaoui</div>
          </div>
        </a>
        <nav class="hidden items-center gap-6 md:flex">
          <a href="../../../#about" class="hover:text-indigo-600 dark:hover:text-indigo-400">About</a>
          <a href="../../../blog/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Blog</a>
          <a href="../../../#skills" class="hover:text-indigo-600 dark:hover:text-indigo-400">Skills</a>
          <a href="../../../projects/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Projects</a>
          <a href="../../../tutorials/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Tutorials</a>
          <a href="../../" class="text-indigo-600 dark:text-indigo-400">Courses</a>
        </nav>
        <button id="themeToggle" class="inline-flex items-center justify-center rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800" aria-label="Toggle theme">
          <svg class="h-5 w-5 dark:hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v2m0 14v2M5.64 5.64l1.41 1.41M16.95 16.95l1.41 1.41M3 12h2m14 0h2M5.64 18.36l1.41-1.41M16.95 7.05l1.41-1.41"/><circle cx="12" cy="12" r="4"/></svg>
          <svg class="hidden h-5 w-5 dark:block" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        </button>
      </div>
    </header>

    <main class="mx-auto max-w-7xl px-6 py-10">
      <div class="lg:flex lg:gap-8">
        <aside class="hidden lg:block lg:w-72">
          <nav class="sticky top-8 rounded-xl border border-slate-200/60 bg-white/60 p-4 shadow-sm backdrop-blur dark:border-slate-800/60 dark:bg-slate-900/40" aria-label="Table of contents">
            <h2 class="mb-3 text-xs font-semibold uppercase tracking-wider text-slate-500 dark:text-slate-400">On this page</h2>
            <ol class="space-y-1 text-sm">
              <li><a href="#introduction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Introduction</a></li>
              <li><a href="#understanding-caching" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Understanding Caching</a></li>
              <li><a href="#spring-cache-abstraction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Spring Cache Abstraction</a></li>
              <li><a href="#cache-annotations" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Annotations</a></li>
              <li><a href="#cache-providers" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Providers</a></li>
              <li><a href="#cache-configuration" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Configuration</a></li>
              <li><a href="#cache-strategies" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Strategies</a></li>
              <li><a href="#distributed-caching" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Distributed Caching</a></li>
              <li><a href="#cache-best-practices" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Cache Best Practices</a></li>
              <li><a href="#summary" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Summary</a></li>
              <li><a href="#programming-challenge" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Programming Challenge</a></li>
            </ol>
          </nav>
        </aside>
        <div class="min-w-0 flex-1">
          <div class="mb-6">
            <a href="../index.html" class="inline-block text-sm text-indigo-600 hover:underline dark:text-indigo-400">← Back to Concepts</a>
          </div>
          <header class="mx-auto max-w-3xl text-center">
            <h1 class="text-center text-3xl font-extrabold tracking-tight sm:text-4xl">Lesson 17: Spring Boot Caching</h1>
            <p class="mt-2 text-slate-600 dark:text-slate-300">Master Spring Boot caching strategies to build high-performance applications that scale efficiently through intelligent data storage and retrieval optimization.</p>
          </header>

          <section id="introduction" class="prose prose-slate mt-6 max-w-none dark:prose-invert">
            <h2>Introduction</h2>
            <p>In modern web applications, performance is paramount, and caching is one of the most effective techniques for achieving optimal response times and scalability. Spring Boot's caching abstraction provides a powerful, flexible framework for implementing intelligent caching strategies that can transform your application's performance characteristics. Think of caching as your application's short-term memory - it remembers frequently accessed information so it doesn't have to perform expensive operations repeatedly. Just as you might keep your most-used tools within arm's reach on your workbench, caching keeps frequently requested data in fast-access storage, dramatically reducing response times and server load. This lesson explores Spring Boot's comprehensive caching capabilities, from simple in-memory caching to sophisticated distributed cache strategies that can handle enterprise-scale applications. You'll learn to implement cache annotations, configure different cache providers, design effective cache strategies, and optimize cache performance for production environments.</p>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="understanding-caching" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Understanding Caching</h2>
            <h3>Definition</h3>
            <ul>
              <li>Caching is a performance optimization technique that stores copies of frequently accessed data in fast-access storage to avoid repeated expensive operations.</li>
              <li>When data is requested, the cache is checked first; if found (cache hit), the cached data is returned immediately.</li>
              <li>If not found (cache miss), the expensive operation is performed, and the result is stored in the cache for future requests.</li>
              <li>Effective caching can reduce database load, improve response times, and enhance overall application scalability by orders of magnitude.</li>
            </ul>

            <h3>Analogy</h3>
            <p>Think of caching like the strategy a busy chef uses in a restaurant kitchen. Instead of going to the main storage room every time they need common ingredients like salt, pepper, or olive oil, the chef keeps frequently used items on the counter within arm's reach. When an order comes in for a dish that needs salt, the chef grabs it from the counter (cache hit) rather than walking to the storage room (database query). This saves time and effort for every dish prepared. Occasionally, an ingredient runs out and the chef must restock from the main storage (cache miss), but this happens much less frequently than if they fetched every ingredient from storage for every dish. The result is faster service and less wear on the chef (server).</p>

            <h3>Examples</h3>
            <p><strong>Without caching - repeated expensive operations:</strong></p>
            <pre><code class="language-java">@Service
public class ProductService {
    public Product getProduct(Long id) {
        // Expensive database query every time
        return productRepository.findById(id);
    }

    public List<Product> getPopularProducts() {
        // Complex aggregation query every time
        return productRepository.findTop10ByOrderBySalesDesc();
    }
}</code></pre>

            <p><strong>With caching - store results for fast retrieval:</strong></p>
            <pre><code class="language-java">@Service
public class ProductService {
    @Cacheable("products")
    public Product getProduct(Long id) {
        // Query once, cache result for subsequent calls
        return productRepository.findById(id);
    }

    @Cacheable("popular-products")
    public List<Product> getPopularProducts() {
        // Expensive operation cached for 1 hour
        return productRepository.findTop10ByOrderBySalesDesc();
    }
}</code></pre>

            <p><strong>Performance impact comparison:</strong></p>
            <pre><code class="language-java">// Without cache:
// - Database query: 200ms per request
// - 1000 requests = 200 seconds total

// With cache:
// - First request: 200ms (cache miss)
// - Next 999 requests: 2ms each (cache hits)
// - Total: 200ms + (999 × 2ms) = 2.2 seconds
// 90x performance improvement!</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="spring-cache-abstraction" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Spring Cache Abstraction</h2>
            <h3>Definition</h3>
            <ul>
              <li>Spring's cache abstraction provides a unified programming model for caching that works with different cache providers without changing your code.</li>
              <li>The abstraction uses annotations to declare caching behavior, automatically handling cache operations like storing, retrieving, and evicting data.</li>
              <li>This means you can switch between cache providers (from simple HashMap to Redis clusters) by changing configuration, not code, providing flexibility and vendor independence.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>Enable caching in Spring Boot:</strong></p>
            <pre><code class="language-java">@SpringBootApplication
@EnableCaching  // Enables Spring's caching support
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}</code></pre>

            <p><strong>Basic cache configuration:</strong></p>
            <pre><code class="language-java">@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        // Simple in-memory cache manager
        SimpleCacheManager manager = new SimpleCacheManager();
        manager.setCaches(Arrays.asList(
            new ConcurrentMapCache("products"),
            new ConcurrentMapCache("users"),
            new ConcurrentMapCache("categories")
        ));
        return manager;
    }
}</code></pre>

            <p><strong>Cache manager with multiple caches:</strong></p>
            <pre><code class="language-java">@Bean
public CacheManager cacheManager() {
    CaffeineCacheManager manager = new CaffeineCacheManager();
    manager.setCacheNames("products", "users", "categories", "search-results");
    manager.setCaffeine(Caffeine.newBuilder()
        .maximumSize(1000)
        .expireAfterWrite(10, TimeUnit.MINUTES));
    return manager;
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-annotations" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Annotations</h2>
            <h3>Definition</h3>
            <ul>
              <li>Spring provides several cache annotations that declaratively define caching behavior without cluttering business logic with cache management code.</li>
              <li>@Cacheable caches method results, @CacheEvict removes cached data, @CachePut updates cache entries, and @Caching combines multiple cache operations.</li>
              <li>These annotations use SpEL (Spring Expression Language) for dynamic cache keys and conditions, providing fine-grained control over when and how caching occurs.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>@Cacheable - cache method results:</strong></p>
            <pre><code class="language-java">@Service
public class ProductService {

    @Cacheable(value = "products", key = "#id")
    public Product findProduct(Long id) {
        System.out.println("Fetching product from database: " + id);
        return productRepository.findById(id);
    }

    @Cacheable(value = "products", key = "#name", condition = "#name.length() > 2")
    public Product findByName(String name) {
        return productRepository.findByName(name);
    }
}</code></pre>

            <p><strong>@CacheEvict - remove cached data:</strong></p>
            <pre><code class="language-java">@CacheEvict(value = "products", key = "#product.id")
public Product updateProduct(Product product) {
    Product updated = productRepository.save(product);
    System.out.println("Cache evicted for product: " + product.getId());
    return updated;
}

@CacheEvict(value = "products", allEntries = true)
public void clearAllProducts() {
    System.out.println("All product cache entries cleared");
}</code></pre>

            <p><strong>@CachePut - update cache:</strong></p>
            <pre><code class="language-java">@CachePut(value = "products", key = "#result.id")
public Product createProduct(Product product) {
    Product saved = productRepository.save(product);
    System.out.println("Product saved and cached: " + saved.getId());
    return saved;
}</code></pre>

            <p><strong>@Caching - combine multiple cache operations:</strong></p>
            <pre><code class="language-java">@Caching(
    evict = {
        @CacheEvict(value = "products", key = "#product.id"),
        @CacheEvict(value = "categories", key = "#product.categoryId")
    }
)
public void deleteProduct(Product product) {
    productRepository.delete(product);
}</code></pre>

            <p><strong>Complex cache key expressions:</strong></p>
            <pre><code class="language-java">@Cacheable(value = "search-results",
           key = "#category + '_' + #minPrice + '_' + #maxPrice",
           unless = "#result.isEmpty()")
public List<Product> searchProducts(String category, BigDecimal minPrice, BigDecimal maxPrice) {
    return productRepository.findByCategoryAndPriceBetween(category, minPrice, maxPrice);
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-providers" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Providers</h2>
            <h3>Definition</h3>
            <ul>
              <li>Cache providers are the underlying storage mechanisms that actually hold cached data.</li>
              <li>Spring Boot supports various providers: ConcurrentHashMap for simple in-memory caching, Caffeine for high-performance local caching with advanced features like size-based eviction and time-based expiration, Redis for distributed caching across multiple servers, and Hazelcast for in-memory data grids.</li>
              <li>Each provider has different characteristics regarding performance, memory management, persistence, and distribution capabilities.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>Caffeine high-performance cache:</strong></p>
            <pre><code class="language-xml">&lt;!-- Add Caffeine dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

            <pre><code class="language-java">@Bean
public CacheManager caffeineCacheManager() {
    CaffeineCacheManager manager = new CaffeineCacheManager();
    manager.setCaffeine(Caffeine.newBuilder()
        .maximumSize(1000)                    // Max 1000 entries
        .expireAfterWrite(10, TimeUnit.MINUTES) // Expire after 10 minutes
        .expireAfterAccess(5, TimeUnit.MINUTES) // Expire if not accessed for 5 minutes
        .recordStats());                      // Enable statistics
    return manager;
}</code></pre>

            <p><strong>Redis distributed cache:</strong></p>
            <pre><code class="language-xml">&lt;!-- Add Redis dependency --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>

            <pre><code class="language-java">@Bean
public CacheManager redisCacheManager(RedisConnectionFactory factory) {
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofMinutes(30))    // 30-minute TTL
        .serializeKeysWith(RedisSerializationContext.SerializationPair
            .fromSerializer(new StringRedisSerializer()))
        .serializeValuesWith(RedisSerializationContext.SerializationPair
            .fromSerializer(new GenericJackson2JsonRedisSerializer()));

    return RedisCacheManager.builder(factory)
        .cacheDefaults(config)
        .transactionAware()
        .build();
}</code></pre>

            <p><strong>Multiple cache managers:</strong></p>
            <pre><code class="language-java">@Configuration
public class MultiCacheConfig {

    @Bean
    @Primary
    public CacheManager localCacheManager() {
        // Fast local cache for frequently accessed data
        return new CaffeineCacheManager("products", "users");
    }

    @Bean
    public CacheManager distributedCacheManager(RedisConnectionFactory factory) {
        // Distributed cache for shared data across instances
        return RedisCacheManager.builder(factory).build();
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-configuration" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Configuration</h2>
            <h3>Definition</h3>
            <ul>
              <li>Cache configuration defines how caches behave regarding size limits, expiration policies, eviction strategies, and serialization.</li>
              <li>Configuration includes setting maximum cache sizes to prevent memory overflow, time-based expiration (TTL) to ensure data freshness, access-based expiration for unused data cleanup, and cache warming strategies for critical data.</li>
              <li>Proper configuration ensures optimal memory usage while maintaining the right balance between performance and data freshness.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>Environment-specific cache configuration:</strong></p>
            <pre><code class="language-properties"># application-dev.properties - Development settings
spring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=5m
logging.level.org.springframework.cache=DEBUG

# application-prod.properties - Production settings
spring.cache.caffeine.spec=maximumSize=10000,expireAfterWrite=30m
spring.cache.redis.time-to-live=1800000</code></pre>

            <p><strong>Advanced cache configurations:</strong></p>
            <pre><code class="language-java">@Configuration
public class CacheConfig {

    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager manager = new CaffeineCacheManager();

        // Short-lived user sessions cache
        manager.registerCustomCache("user-sessions",
            Caffeine.newBuilder()
                .expireAfterAccess(30, TimeUnit.MINUTES)
                .maximumSize(5000)
                .build());

        // Long-lived reference data cache
        manager.registerCustomCache("reference-data",
            Caffeine.newBuilder()
                .expireAfterWrite(4, TimeUnit.HOURS)
                .maximumSize(1000)
                .build());

        // Frequently accessed products with refresh ahead
        manager.registerCustomCache("hot-products",
            Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .refreshAfterWrite(45, TimeUnit.MINUTES)
                .maximumSize(2000)
                .build());

        return manager;
    }
}</code></pre>

            <p><strong>Cache with custom serialization:</strong></p>
            <pre><code class="language-java">@Bean
public RedisCacheManager redisCacheManager(RedisConnectionFactory factory) {
    // Configure JSON serialization for complex objects
    RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
        .entryTtl(Duration.ofHours(1))
        .serializeValuesWith(RedisSerializationContext.SerializationPair
            .fromSerializer(new GenericJackson2JsonRedisSerializer()));

    // Different TTL for different caches
    Map<String, RedisCacheConfiguration> cacheConfigs = new HashMap<>();
    cacheConfigs.put("products", config.entryTtl(Duration.ofMinutes(30)));
    cacheConfigs.put("users", config.entryTtl(Duration.ofHours(2)));
    cacheConfigs.put("reference-data", config.entryTtl(Duration.ofDays(1)));

    return RedisCacheManager.builder(factory)
        .cacheDefaults(config)
        .withInitialCacheConfigurations(cacheConfigs)
        .build();
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-strategies" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Strategies</h2>
            <h3>Definition</h3>
            <ul>
              <li>Cache strategies define when and how data is loaded into and removed from the cache.</li>
              <li>Common strategies include Cache-Aside (application manages cache), Write-Through (write to cache and database simultaneously), Write-Behind (write to cache immediately, database later), and Read-Through (cache loads data automatically on miss).</li>
              <li>Each strategy has trade-offs between consistency, performance, and complexity, making strategy selection crucial for application requirements.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>Cache-Aside pattern (most common):</strong></p>
            <pre><code class="language-java">@Service
public class ProductService {

    @Cacheable("products")
    public Product getProduct(Long id) {
        // Cache-aside: check cache first, load from DB on miss
        return productRepository.findById(id);
    }

    @CacheEvict(value = "products", key = "#product.id")
    public Product updateProduct(Product product) {
        // Update database and remove from cache
        return productRepository.save(product);
    }
}</code></pre>

            <p><strong>Write-Through pattern:</strong></p>
            <pre><code class="language-java">@Service
public class UserService {

    @CachePut(value = "users", key = "#user.id")
    public User saveUser(User user) {
        // Write-through: save to database and update cache
        User saved = userRepository.save(user);
        logger.info("User saved to database and cache: {}", saved.getId());
        return saved;
    }
}</code></pre>

            <p><strong>Cache warming strategy:</strong></p>
            <pre><code class="language-java">@Component
public class CacheWarmupService {

    @Autowired
    private ProductService productService;

    @EventListener(ApplicationReadyEvent.class)
    public void warmupCache() {
        logger.info("Starting cache warmup...");

        // Warm up with popular products
        List<Long> popularProductIds = productRepository.findPopularProductIds();
        popularProductIds.forEach(id -> {
            try {
                productService.getProduct(id); // This will populate the cache
            } catch (Exception e) {
                logger.warn("Failed to warm cache for product: {}", id, e);
            }
        });

        logger.info("Cache warmup completed for {} products", popularProductIds.size());
    }
}</code></pre>

            <p><strong>Multi-level caching strategy:</strong></p>
            <pre><code class="language-java">@Service
public class MultiLevelCacheService {

    @Cacheable(value = "l1-cache", key = "#id") // Level 1: Fast local cache
    public Product getProductL1(Long id) {
        return getProductL2(id);
    }

    @Cacheable(value = "l2-cache", key = "#id") // Level 2: Distributed cache
    public Product getProductL2(Long id) {
        logger.info("Loading from database: {}", id);
        return productRepository.findById(id);
    }

    @CacheEvict(value = {"l1-cache", "l2-cache"}, key = "#id")
    public void evictProduct(Long id) {
        logger.info("Evicted product from all cache levels: {}", id);
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="distributed-caching" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Distributed Caching</h2>
            <h3>Definition</h3>
            <ul>
              <li>Distributed caching extends caching across multiple application instances or servers, providing shared cache storage that all instances can access.</li>
              <li>This enables horizontal scaling while maintaining cache consistency and eliminates cache warm-up requirements for new instances.</li>
              <li>Distributed caching is essential for microservices architectures and applications running on multiple servers or containers.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>Redis cluster configuration:</strong></p>
            <pre><code class="language-properties"># application.properties
spring.redis.cluster.nodes=redis1:6379,redis2:6379,redis3:6379
spring.redis.cluster.max-redirects=3
spring.redis.timeout=2000ms
spring.redis.lettuce.pool.max-active=8
spring.redis.lettuce.pool.max-idle=8</code></pre>

            <p><strong>Distributed cache with fallback:</strong></p>
            <pre><code class="language-java">@Service
public class RobustCacheService {

    @Autowired
    private CacheManager distributedCacheManager;

    @Autowired
    private CacheManager localCacheManager;

    public Product getProduct(Long id) {
        try {
            // Try distributed cache first
            Cache distributedCache = distributedCacheManager.getCache("products");
            Product product = distributedCache.get(id, Product.class);

            if (product != null) {
                return product;
            }
        } catch (Exception e) {
            logger.warn("Distributed cache unavailable, falling back to local cache", e);
        }

        // Fallback to local cache and database
        return getFromLocalCacheOrDatabase(id);
    }

    private Product getFromLocalCacheOrDatabase(Long id) {
        Cache localCache = localCacheManager.getCache("products");
        return localCache.get(id, () -> productRepository.findById(id));
    }
}</code></pre>

            <p><strong>Cache synchronization across instances:</strong></p>
            <pre><code class="language-java">@Component
public class CacheSyncService {

    @EventListener
    public void handleProductUpdate(ProductUpdateEvent event) {
        // Notify other instances to evict cache
        messagingService.broadcast("cache.evict.product", event.getProductId());
    }

    @RabbitListener(queues = "cache.evict.product")
    public void handleCacheEviction(Long productId) {
        cacheManager.getCache("products").evict(productId);
        logger.info("Evicted product {} from local cache due to remote update", productId);
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="cache-best-practices" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Cache Best Practices</h2>
            <h3>Definition</h3>
            <ul>
              <li>Cache best practices ensure optimal performance, memory usage, and data consistency while avoiding common pitfalls.</li>
              <li>These include choosing appropriate cache keys, setting reasonable TTL values, implementing cache warming for critical data, monitoring cache performance, handling cache failures gracefully, and avoiding cache stampedes.</li>
              <li>Following best practices prevents memory leaks, ensures cache effectiveness, and maintains application reliability.</li>
            </ul>

            <h3>Examples</h3>
            <p><strong>Effective cache key design:</strong></p>
            <pre><code class="language-java">@Service
public class CacheKeyService {

    // Good: Specific, hierarchical keys
    @Cacheable(value = "products", key = "'product:' + #id + ':' + #locale")
    public Product getLocalizedProduct(Long id, String locale) {
        return productService.getProductWithLocalization(id, locale);
    }

    // Good: Include version for cache invalidation
    @Cacheable(value = "api-responses",
               key = "'v1:products:' + #category + ':page:' + #page")
    public ApiResponse getProductPage(String category, int page) {
        return apiService.getProducts(category, page);
    }

    // Good: Handle null parameters
    @Cacheable(value = "search-results",
               key = "'search:' + (#query ?: 'empty') + ':' + (#filters ?: 'none')")
    public SearchResults search(String query, Map<String, String> filters) {
        return searchService.search(query, filters);
    }
}</code></pre>

            <p><strong>Cache performance monitoring:</strong></p>
            <pre><code class="language-java">@Component
public class CachePerformanceMonitor {

    private final MeterRegistry meterRegistry;

    @EventListener
    public void onCacheHit(CacheHitEvent event) {
        meterRegistry.counter("cache.hits",
            "cache", event.getCacheName()).increment();
    }

    @EventListener
    public void onCacheMiss(CacheMissEvent event) {
        meterRegistry.counter("cache.misses",
            "cache", event.getCacheName()).increment();
    }

    @Scheduled(fixedRate = 60000) // Every minute
    public void logCacheStatistics() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache.getNativeCache() instanceof com.github.benmanes.caffeine.cache.Cache) {
                var stats = ((com.github.benmanes.caffeine.cache.Cache<?, ?>)
                    cache.getNativeCache()).stats();

                logger.info("Cache {}: hit rate={:.2f}%, size={}, evictions={}",
                    cacheName, stats.hitRate() * 100,
                    cache.getNativeCache().size(), stats.evictionCount());
            }
        });
    }
}</code></pre>

            <p><strong>Graceful cache degradation:</strong></p>
            <pre><code class="language-java">@Service
public class FaultTolerantCacheService {

    @Retryable(value = CacheException.class, maxAttempts = 3)
    @Cacheable(value = "products", key = "#id")
    public Product getProduct(Long id) {
        return productRepository.findById(id);
    }

    @Recover
    public Product recoverFromCacheFailure(CacheException ex, Long id) {
        logger.warn("Cache operation failed, fetching directly from database: {}", id, ex);
        // Fetch directly without caching
        return productRepository.findById(id);
    }

    // Prevent cache stampede with synchronized cache loading
    @Cacheable(value = "expensive-computation", sync = true)
    public ExpensiveResult performExpensiveOperation(String input) {
        logger.info("Performing expensive operation for: {}", input);
        return computationService.compute(input);
    }
}</code></pre>

            <p><strong>Cache configuration best practices:</strong></p>
            <pre><code class="language-java">@Configuration
public class OptimalCacheConfig {

    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager manager = new CaffeineCacheManager();

        // Configure based on data characteristics
        manager.registerCustomCache("user-profiles",
            Caffeine.newBuilder()
                .maximumSize(10000)           // Limit memory usage
                .expireAfterWrite(1, TimeUnit.HOURS)    // Data freshness
                .refreshAfterWrite(45, TimeUnit.MINUTES) // Proactive refresh
                .recordStats()                // Monitor performance
                .build());

        manager.registerCustomCache("session-data",
            Caffeine.newBuilder()
                .maximumSize(50000)
                .expireAfterAccess(30, TimeUnit.MINUTES) // Session timeout
                .recordStats()
                .build());

        return manager;
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="summary" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Summary</h2>
            <p>You've now mastered Spring Boot's comprehensive caching capabilities, from basic cache annotations to sophisticated distributed caching strategies. You understand how caching transforms application performance by storing frequently accessed data in fast-access storage, reducing expensive operations and improving response times dramatically. You've learned to implement cache annotations for declarative caching behavior, configure different cache providers from simple in-memory solutions to enterprise-grade distributed systems, and design effective cache strategies that balance performance with data consistency. The concepts of cache keys, TTL configuration, eviction policies, and cache warming ensure your caching implementation is both performant and reliable. You've also explored distributed caching for scalable applications, multi-level caching strategies for optimal performance, and best practices for monitoring and maintaining cache health in production environments. These skills enable you to build applications that can handle high loads efficiently while providing excellent user experience through optimized data access patterns. Your next lesson will integrate caching with comprehensive monitoring and application performance optimization techniques.</p>
          </section>

          <section id="programming-challenge" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Programming Challenge</h2>
            <div class="rounded-lg border border-slate-200 bg-slate-50 p-6 dark:border-slate-700 dark:bg-slate-800">
              <h3 class="mt-0">Challenge: High-Performance E-commerce Caching System</h3>
              <p><strong>Task:</strong> Build a Spring Boot e-commerce application with a sophisticated multi-level caching strategy that demonstrates various caching patterns, performance optimization, and intelligent cache management.</p>

              <p><strong>Requirements:</strong></p>
              <ol>
                <li>Create core entities and services:</li>
                <ul>
                  <li><code>Product</code>, <code>Category</code>, <code>User</code>, <code>Order</code>, <code>Review</code> entities</li>
                  <li>Repository layer with complex queries and aggregations</li>
                  <li>Service layer implementing business logic with multiple data access patterns</li>
                  <li>REST controllers for product catalog, user management, and order processing</li>
                </ul>
                <li>Implement multi-level caching strategy:</li>
                <ul>
                  <li>L1 Cache: Individual entities (products, users) with 1-hour TTL</li>
                  <li>L2 Cache: Collections and search results (categories, popular products) with 30-min TTL</li>
                  <li>L3 Cache: Aggregated data (statistics, reports) with 4-hour TTL</li>
                  <li>L4 Cache: Reference data (configurations, settings) with daily TTL</li>
                </ul>
                <li>Demonstrate various caching patterns:</li>
                <ul>
                  <li>Cache-aside pattern for product catalog</li>
                  <li>Write-through pattern for user profiles</li>
                  <li>Write-behind pattern for analytics data</li>
                  <li>Read-through pattern for computed recommendations</li>
                </ul>
                <li>Implement intelligent cache management:</li>
                <ul>
                  <li>Cache warming service that preloads popular products at startup</li>
                  <li>Event-driven cache invalidation when products are updated</li>
                  <li>Bulk cache operations for administrative tasks</li>
                  <li>Cache synchronization across multiple application instances</li>
                </ul>
                <li>Add performance optimization features:</li>
                <ul>
                  <li>Conditional caching based on product popularity and user behavior</li>
                  <li>Cache compression for large objects (product catalogs, order history)</li>
                  <li>Cache partitioning by user segments or geographic regions</li>
                  <li>Async cache refresh to prevent cache stampedes</li>
                </ul>
                <li>Create cache monitoring and management:</li>
                <ul>
                  <li>Cache statistics tracking (hit rates, eviction counts, memory usage)</li>
                  <li>Performance comparison endpoints (with/without cache)</li>
                  <li>Administrative endpoints for cache management and clearing</li>
                  <li>Cache health indicators and alerts for cache failures</li>
                </ul>
                <li>Implement distributed caching with Redis:</li>
                <ul>
                  <li>Configure Redis for session storage and shared cache data</li>
                  <li>Implement cache failover from Redis to local cache</li>
                  <li>Cache clustering and data partitioning strategies</li>
                  <li>Cross-instance cache invalidation messaging</li>
                </ul>
              </ol>

              <p><strong>Bonus features:</strong></p>
              <ul>
                <li>Machine learning-based cache warming using user behavior patterns</li>
                <li>Geographic cache distribution with regional data centers</li>
                <li>Cache versioning system for rolling updates without cache misses</li>
                <li>A/B testing framework for different caching strategies</li>
                <li>Real-time cache analytics dashboard with performance metrics</li>
                <li>Intelligent cache eviction based on business value and access patterns</li>
              </ul>

              <p><strong>Learning Goals:</strong> Master comprehensive caching strategies, understand performance implications of different cache patterns, implement production-ready cache management, practice distributed caching concepts, and build systems that demonstrate measurable performance improvements through intelligent caching.</p>
            </div>
          </section>

          <nav class="mt-12 flex items-center justify-between border-t border-slate-200/60 pt-6 dark:border-slate-800/60">
            <a href="lesson-16.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Previous</a>
            <a href="lesson-18.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Next</a>
          </nav>
        </div>
      </div>
    </main>

    <footer class="border-t border-slate-200/60 py-10 text-center text-sm text-slate-500 dark:border-slate-800/60 dark:text-slate-400">
      <div class="mx-auto max-w-7xl px-6">
        <p>© 2025 wassim lagnaoui. All rights reserved.</p>
      </div>
    </footer>

    <script>
      document.getElementById('themeToggle').addEventListener('click', function(){
        const r=document.documentElement; const d=r.classList.toggle('dark');
        try{localStorage.setItem('theme', d?'dark':'light');}catch{}
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      if (window.Prism && Prism.plugins && Prism.plugins.autoloader) {
        Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1/components/';
        Prism.highlightAll();
      }
    </script>
  </body>
</html>

<!doctype html>
<html lang="en" class="scroll-smooth">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lesson 14 - Spring Boot Data Access with JPA and Hibernate part 2</title>
    <meta name="description" content="Spring Boot JPA and Hibernate part 2: entity relationships, custom queries, performance optimization, and advanced mapping techniques with practical examples." />
    <script>(function(){try{const t=localStorage.getItem('theme');const d=matchMedia('(prefers-color-scheme: dark)').matches;if(t==='dark'||(!t&&d))document.documentElement.classList.add('dark');}catch{}})();</script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      tailwind.config = { darkMode:'class', theme:{ extend:{ fontFamily:{ sans:["Inter var","Inter","ui-sans-serif","system-ui","-apple-system","Segoe UI","Roboto","Helvetica","Arial","Noto Sans","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"] } } } };
    </script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css" />
    <link rel="stylesheet" href="../../../tutorials/tutorials.css" />
  </head>
  <body class="bg-white text-slate-800 antialiased dark:bg-slate-950 dark:text-slate-100">
    <div aria-hidden="true" class="pointer-events-none fixed inset-0 -z-10"><div class="absolute inset-0 bg-gradient-to-br from-indigo-500/10 via-fuchsia-500/10 to-emerald-500/10 blur-2xl"></div></div>

    <header class="z-20 backdrop-blur supports-[backdrop-filter]:bg-white/60 supports-[backdrop-filter]:dark:bg-slate-950/40 border-b border-slate-200/60 dark:border-slate-800/60">
      <div class="mx-auto flex max-w-7xl items-center justify-between gap-4 px-6 py-4">
        <a href="../../../" class="group inline-flex items-center gap-3">
          <span class="grid h-9 w-9 place-items-center rounded-lg bg-indigo-600 text-white shadow-md shadow-indigo-600/30">WL</span>
          <div class="leading-tight">
            <div class="text-sm text-slate-500 dark:text-slate-400">Java Full Stack Developer</div>
            <div class="font-semibold">Wassim Lagnaoui</div>
          </div>
        </a>
        <nav class="hidden items-center gap-6 md:flex">
          <a href="../../../#about" class="hover:text-indigo-600 dark:hover:text-indigo-400">About</a>
          <a href="../../../blog/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Blog</a>
          <a href="../../../#skills" class="hover:text-indigo-600 dark:hover:text-indigo-400">Skills</a>
          <a href="../../../projects/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Projects</a>
          <a href="../../../tutorials/" class="hover:text-indigo-600 dark:hover:text-indigo-400">Tutorials</a>
          <a href="../../" class="text-indigo-600 dark:text-indigo-400">Courses</a>
        </nav>
        <button id="themeToggle" class="inline-flex items-center justify-center rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800" aria-label="Toggle theme">
          <svg class="h-5 w-5 dark:hidden" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v2m0 14v2M5.64 5.64l1.41 1.41M16.95 16.95l1.41 1.41M3 12h2m14 0h2M5.64 18.36l1.41-1.41M16.95 7.05l1.41-1.41"/><circle cx="12" cy="12" r="4"/></svg>
          <svg class="hidden h-5 w-5 dark:block" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
        </button>
      </div>
    </header>

    <main class="mx-auto max-w-7xl px-6 py-10">
      <div class="lg:flex lg:gap-8">
        <aside class="hidden lg:block lg:w-72">
          <nav class="sticky top-8 rounded-xl border border-slate-200/60 bg-white/60 p-4 shadow-sm backdrop-blur dark:border-slate-800/60 dark:bg-slate-900/40" aria-label="Table of contents">
            <h2 class="mb-3 text-xs font-semibold uppercase tracking-wider text-slate-500 dark:text-slate-400">On this page</h2>
            <ol class="space-y-1 text-sm">
              <li><a href="#introduction" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Introduction</a></li>
              <li><a href="#entity-relationships" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Entity Relationships</a></li>
              <li><a href="#onetoone-mapping" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">One-to-One Mapping</a></li>
              <li><a href="#onetomany-mapping" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">One-to-Many Mapping</a></li>
              <li><a href="#manytomany-mapping" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Many-to-Many Mapping</a></li>
              <li><a href="#custom-queries" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Custom Queries</a></li>
              <li><a href="#jpql-queries" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">JPQL Queries</a></li>
              <li><a href="#native-queries" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Native Queries</a></li>
              <li><a href="#pagination-sorting" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Pagination & Sorting</a></li>
              <li><a href="#lazy-eager-loading" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Lazy vs Eager Loading</a></li>
              <li><a href="#n-plus-one-problem" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">N+1 Query Problem</a></li>
              <li><a href="#transaction-management" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Transaction Management</a></li>
              <li><a href="#connection-management" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Connection Management</a></li>
              <li><a href="#performance-optimization" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Performance Optimization</a></li>
              <li><a href="#summary" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Summary</a></li>
              <li><a href="#programming-challenge" class="block rounded-md px-3 py-1.5 hover:bg-slate-100 dark:hover:bg-slate-800/60">Programming Challenge</a></li>
            </ol>
          </nav>
        </aside>
        <div class="min-w-0 flex-1">
          <div class="mb-6">
            <a href="../index.html" class="inline-block text-sm text-indigo-600 hover:underline dark:text-indigo-400">‚Üê Back to Concepts</a>
          </div>
          <header class="mx-auto max-w-3xl text-center">
            <h1 class="text-center text-3xl font-extrabold tracking-tight sm:text-4xl">Lesson 14: Spring Boot Data Access with JPA and Hibernate part 2</h1>
            <p class="mt-2 text-slate-600 dark:text-slate-300">Master advanced JPA concepts: entity relationships, custom queries, performance optimization, and sophisticated data modeling for complex applications.</p>
          </header>

          <section id="introduction" class="prose prose-slate mt-6 max-w-none dark:prose-invert">
            <h2>Introduction</h2>
            <p>Real-world applications rarely work with isolated data - customers have orders, orders contain products, students enroll in courses, and blog posts have comments. Building on the JPA fundamentals you learned in part 1, this lesson explores the advanced features that make JPA truly powerful for complex applications. You'll learn to model relationships between entities, write custom queries that go beyond simple finders, optimize performance through lazy loading and fetch strategies, and handle large datasets with pagination. These advanced techniques are essential for building scalable applications that can handle real-world data complexity. From one-to-one relationships like users and profiles, to many-to-many associations like students and courses, you'll master the art of expressing complex business relationships in clean, maintainable code. This lesson transforms you from someone who can store and retrieve individual objects into a developer who can architect sophisticated, high-performance data models.</p>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="entity-relationships" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Entity Relationships</h2>
            <h3>Definition</h3>
            <p>Entity relationships define how different database tables connect to each other, mirroring real-world associations between objects. JPA provides annotations to map these relationships: @OneToOne for exclusive pairings, @OneToMany for parent-child hierarchies, @ManyToOne for the reverse direction, and @ManyToMany for complex associations. Understanding relationships is crucial because most business domains involve interconnected data that needs to be navigated efficiently and consistently.</p>

            <h3>Analogy</h3>
            <p>Think of entity relationships like connections in a large family tree or organizational chart. A person has one birth certificate (one-to-one), a parent can have many children (one-to-many), many children belong to one parent (many-to-one), and people can belong to multiple clubs while clubs have multiple members (many-to-many). Just as you can trace relationships in a family tree - finding someone's siblings, parents, or cousins - JPA relationships let you navigate between related data objects. The database acts like a sophisticated filing system that automatically maintains these connections, so when you look up a person, you can instantly access their family members, and when family structures change, all the connections update accordingly.</p>

            <h3>Examples</h3>
            <p><strong>Understanding relationship types:</strong></p>
            <pre><code class="language-java">// One-to-One: User ‚Üî Profile (each user has exactly one profile)
// One-to-Many: Author ‚Üí Books (one author writes many books)
// Many-to-One: Books ‚Üí Author (many books belong to one author)
// Many-to-Many: Students ‚Üî Courses (students take multiple courses, courses have multiple students)
</code></pre>

            <p><strong>Bidirectional vs Unidirectional:</strong></p>
            <pre><code class="language-java">// Bidirectional: Can navigate both ways (Author ‚Üí Books, Book ‚Üí Author)
// Unidirectional: Navigate only one way (Author ‚Üí Books only)
</code></pre>

            <p><strong>Owning side vs Non-owning side:</strong></p>
            <pre><code class="language-java">// Owning side: Contains foreign key, controls relationship
// Non-owning side: Uses mappedBy attribute, mirrors the relationship
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="onetoone-mapping" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>One-to-One Mapping</h2>
            <h3>Definition</h3>
            <p>One-to-one relationships connect exactly one entity to exactly one other entity, like a user and their profile, or a person and their passport. The @OneToOne annotation establishes this connection, typically with one side owning the foreign key. This relationship type is perfect for splitting large entities into logical pieces or for optional extensions where not every record needs the additional data.</p>

            <h3>Analogy</h3>
            <p>Think of a one-to-one relationship like the connection between a person and their driver's license. Each person can have at most one valid driver's license, and each driver's license belongs to exactly one person. You can't share a license, and you can't have multiple valid licenses at the same time. In a government database, the person's basic information (name, address, birth date) might be stored in one table, while driving-specific information (license number, restrictions, expiration date) is stored in a separate but connected table. This separation keeps the main person record clean while allowing detailed driving information for those who need it, just like how user profiles extend basic user accounts with additional personal details.</p>

            <h3>Examples</h3>
            <p><strong>User and Profile relationship:</strong></p>
            <pre><code class="language-java">@Entity
public class User {
    @Id @GeneratedValue
    private Long id;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id")
    private Profile profile;
}
</code></pre>

            <p><strong>Profile side of relationship:</strong></p>
            <pre><code class="language-java">@Entity
public class Profile {
    @Id @GeneratedValue
    private Long id;

    @OneToOne(mappedBy = "profile")
    private User user;  // Non-owning side
}
</code></pre>

            <p><strong>Creating and linking entities:</strong></p>
            <pre><code class="language-java">User user = new User("alice@example.com");
Profile profile = new Profile("Alice", "Smith", "Software Developer");
user.setProfile(profile);
userRepository.save(user);  // Saves both user and profile
</code></pre>

            <p><strong>Querying with joins:</strong></p>
            <pre><code class="language-java">@Query("SELECT u FROM User u JOIN FETCH u.profile WHERE u.email = ?1")
Optional&lt;User&gt; findUserWithProfile(String email);</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="onetomany-mapping" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>One-to-Many Mapping</h2>
            <h3>Definition</h3>
            <p>One-to-many relationships connect one entity to multiple related entities, like an author having many books, or a blog post having many comments. The @OneToMany annotation on the parent side pairs with @ManyToOne on the child side. The child entity typically holds the foreign key that points back to the parent. This relationship type is fundamental for modeling hierarchical data and parent-child structures that appear throughout business applications.</p>

            <h3>Analogy</h3>
            <p>Imagine a library where each author can write multiple books, but each book has only one primary author. The library's computer system links all of Stephen King's novels to his author record, so when you look up Stephen King, you can see his entire catalog. Conversely, when you pick up any Stephen King book, you can immediately see who wrote it. This is exactly how one-to-many relationships work in databases - the author entity connects to multiple book entities, while each book connects back to its one author. The relationship is like invisible threads connecting related items, maintained automatically by the database so you can easily navigate from parents to children and back again.</p>

            <h3>Examples</h3>
            <p><strong>Author with many Books:</strong></p>
            <pre><code class="language-java">@Entity
public class Author {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL)
    private List&lt;Book&gt; books = new ArrayList&lt;&gt;();</code></pre>

            <p><strong>Book belongs to one Author:</strong></p>
            <pre><code class="language-java">@Entity
public class Book {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "author_id")
    private Author author;  // Owning side with foreign key
}
</code></pre>

            <p><strong>Adding books to author:</strong></p>
            <pre><code class="language-java">Author author = new Author("Stephen King");
Book book1 = new Book("The Shining");
Book book2 = new Book("It");

author.addBook(book1);  // Helper method sets both sides
author.addBook(book2);
authorRepository.save(author);
</code></pre>

            <p><strong>Helper method for bidirectional consistency:</strong></p>
            <pre><code class="language-java">public void addBook(Book book) {
    books.add(book);
    book.setAuthor(this);  // Keep both sides in sync
}
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="manytomany-mapping" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Many-to-Many Mapping</h2>
            <h3>Definition</h3>
            <p>Many-to-many relationships allow multiple entities on both sides to be associated with each other, like students enrolling in courses, or products belonging to multiple categories. JPA uses a join table (junction table) to store these relationships, with the @ManyToMany annotation managing the complexity. One side must be designated as the owning side using the @JoinTable annotation, while the other side uses mappedBy to indicate it's the non-owning side.</p>

            <h3>Analogy</h3>
            <p>Think of many-to-many relationships like the connection between actors and movies. Each actor can appear in multiple movies, and each movie features multiple actors. To track these relationships, Hollywood maintains detailed records (like a join table) that list every actor-movie combination. When you look up Tom Hanks, you see all his movies; when you look up Forrest Gump, you see all its actors. This cross-referencing system lets you navigate relationships in both directions without storing duplicate information. The join table acts like a sophisticated address book that maintains all the connections, automatically updated when actors join new projects or leave old ones, ensuring the relationships stay accurate and current.</p>

            <h3>Examples</h3>
            <p><strong>Student and Course relationship:</strong></p>
            <pre><code class="language-java">@Entity
public class Student {
    @Id @GeneratedValue
    private Long id;

    @ManyToMany
    @JoinTable(name = "student_course",
               joinColumns = @JoinColumn(name = "student_id"),
               inverseJoinColumns = @JoinColumn(name = "course_id"))
    private Set&lt;Course&gt; courses = new HashSet&lt;&gt;();</code></pre>

            <p><strong>Course side of relationship:</strong></p>
            <pre><code class="language-java">@Entity
public class Course {
    @Id @GeneratedValue
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private Set&lt;Student&gt; students = new HashSet&lt;&gt;();  // Non-owning side
}
</code></pre>

            <p><strong>Enrolling students in courses:</strong></p>
            <pre><code class="language-java">Student alice = studentRepository.findByName("Alice");
Course java = courseRepository.findByName("Java Programming");
alice.getCourses().add(java);
studentRepository.save(alice);  // Updates join table
</code></pre>

            <p><strong>Query for courses with student count:</strong></p>
            <pre><code class="language-java">@Query("SELECT c, SIZE(c.students) FROM Course c")
List&lt;Object[]&gt; findCoursesWithEnrollmentCount();</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="custom-queries" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Custom Queries</h2>
            <h3>Definition</h3>
            <p>Custom queries let you write specific database operations that go beyond the automatic query methods provided by Spring Data JPA. Using the @Query annotation, you can write JPQL (Java Persistence Query Language) or native SQL queries directly in your repository interfaces. Custom queries are essential when you need complex filtering, joins across multiple tables, aggregate functions, or specific performance optimizations that simple method names can't express.</p>

            <h3>Analogy</h3>
            <p>Think of custom queries like having a conversation with a librarian who speaks your language fluently. While the library's catalog system can handle simple requests like "find books by author X" or "show me all science fiction books," sometimes you need to ask more complex questions: "Show me all mystery novels published after 2000 by authors who have written at least three books, ordered by publication date." For these sophisticated requests, you need to speak the librarian's specialized language (JPQL or SQL) to get exactly what you want. The librarian understands both casual English (method names) and technical library science terminology (custom queries), using whichever approach best serves your specific information needs.</p>

            <h3>Examples</h3>
            <p><strong>JPQL query with parameters:</strong></p>
            <pre><code class="language-java">@Query("SELECT u FROM User u WHERE u.age BETWEEN :minAge AND :maxAge")
List&lt;User&gt; findUsersByAgeRange(@Param("minAge") int min, @Param("maxAge") int max);</code></pre>

            <p><strong>Complex join query:</strong></p>
            <pre><code class="language-java">@Query("SELECT DISTINCT a FROM Author a JOIN a.books b WHERE b.category = :category")
List&lt;Author&gt; findAuthorsByBookCategory(@Param("category") String category);</code></pre>

            <p><strong>Aggregate query with grouping:</strong></p>
            <pre><code class="language-java">@Query("SELECT a.name, COUNT(b) FROM Author a JOIN a.books b GROUP BY a.name")
List&lt;Object[]&gt; findAuthorBookCounts();</code></pre>

            <p><strong>Update query:</strong></p>
            <pre><code class="language-java">@Modifying
@Query("UPDATE User u SET u.lastLogin = CURRENT_TIMESTAMP WHERE u.id = :id")
int updateLastLogin(@Param("id") Long userId);
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="jpql-queries" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>JPQL Queries</h2>
            <h3>Definition</h3>
            <p>JPQL (Java Persistence Query Language) is an object-oriented query language that works with entity objects rather than database tables. It looks similar to SQL but operates on your Java entity classes and their relationships. JPQL queries are database-independent and automatically translate to the appropriate SQL dialect for your database. This abstraction lets you write queries that focus on your business objects while JPA handles the database-specific details.</p>

            <h3>Analogy</h3>
            <p>JPQL is like having a universal translator that speaks "business language" instead of "database language." When you want to find information, you speak in terms of the business concepts you understand - customers, orders, products - rather than having to think about foreign keys, table joins, and column names. You say "find all customers who have placed orders worth more than $100" instead of "SELECT c.* FROM customers c INNER JOIN orders o ON c.id = o.customer_id WHERE o.total > 100." The translator (JPQL) understands your business-focused request and converts it into whatever technical database language is needed, whether it's MySQL, PostgreSQL, or Oracle, letting you focus on what you want rather than how the database stores it.</p>

            <h3>Examples</h3>
            <p><strong>Basic JPQL syntax:</strong></p>
            <pre><code class="language-java">@Query("SELECT u FROM User u WHERE u.email LIKE :pattern")
List&lt;User&gt; findByEmailPattern(@Param("pattern") String pattern);</code></pre>

            <p><strong>JPQL with relationships:</strong></p>
            <pre><code class="language-java">@Query("SELECT o FROM Order o JOIN o.customer c WHERE c.name = :customerName")
List&lt;Order&gt; findOrdersByCustomerName(@Param("customerName") String name);</code></pre>

            <p><strong>JPQL functions and expressions:</strong></p>
            <pre><code class="language-java">@Query("SELECT u FROM User u WHERE UPPER(u.name) = UPPER(:name) AND u.createdDate > :date")
List&lt;User&gt; findRecentUsersByName(@Param("name") String name, @Param("date") LocalDate date);</code></pre>

            <p><strong>JPQL with subqueries:</strong></p>
            <pre><code class="language-java">@Query("SELECT u FROM User u WHERE u.id IN (SELECT o.customer.id FROM Order o WHERE o.total > :amount)")
List&lt;User&gt; findCustomersWithLargeOrders(@Param("amount") BigDecimal amount);</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="native-queries" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Native Queries</h2>
            <h3>Definition</h3>
            <p>Native queries use raw SQL specific to your database vendor, giving you access to database-specific features, optimizations, or complex operations that JPQL can't express. While they sacrifice database independence, native queries are powerful for performance-critical operations, complex reporting, or when you need database-specific functions. Use native queries sparingly and only when JPQL isn't sufficient for your needs.</p>

            <h3>Analogy</h3>
            <p>Native queries are like speaking directly to a specialist in their technical language instead of using a translator. While the universal translator (JPQL) handles most conversations perfectly, sometimes you need to communicate complex, specialized concepts that require the precision and power of speaking the expert's native language. A database specialist might understand advanced optimization techniques, specific performance tricks, or specialized functions that don't translate well through the universal system. You lose the convenience of automatic translation to other languages, but you gain access to the full depth and sophistication that comes with direct, expert-level communication.</p>

            <h3>Examples</h3>
            <p><strong>Native SQL query:</strong></p>
            <pre><code class="language-java">@Query(value = "SELECT * FROM users WHERE created_date > NOW() - INTERVAL 30 DAY",
       nativeQuery = true)
List&lt;User&gt; findRecentUsers();</code></pre>

            <p><strong>Native query with complex joins:</strong></p>
            <pre><code class="language-java">@Query(value = """
    SELECT u.name, COUNT(o.id) as order_count, SUM(o.total) as total_spent
    FROM users u LEFT JOIN orders o ON u.id = o.customer_id
    GROUP BY u.id, u.name HAVING COUNT(o.id) > :minOrders
    """, nativeQuery = true)
List&lt;Object[]&gt; findTopCustomers(@Param("minOrders") int minOrders);</code></pre>

            <p><strong>Database-specific functions:</strong></p>
            <pre><code class="language-java">@Query(value = "SELECT * FROM products WHERE MATCH(name, description) AGAINST(:search)",
       nativeQuery = true)
List&lt;Product&gt; fullTextSearch(@Param("search") String searchTerm);</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="pagination-sorting" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Pagination & Sorting</h2>
            <h3>Definition</h3>
            <p>Pagination breaks large result sets into smaller, manageable chunks, while sorting organizes data in meaningful order. Spring Data JPA provides Pageable and Sort parameters that automatically generate LIMIT/OFFSET clauses and ORDER BY statements. This is essential for applications that handle large datasets, providing better performance and user experience by loading only the data currently needed rather than overwhelming users with thousands of results at once.</p>

            <h3>Analogy</h3>
            <p>Pagination and sorting are like organizing a massive library catalog into manageable sections with a logical order. Instead of presenting visitors with a overwhelming dump of all 50,000 books at once, the library creates a user-friendly browsing system: books are sorted alphabetically by title or author, then divided into pages showing 20 books each. Visitors can easily navigate through "Page 1 of 2,500" to find what they want, jumping to specific sections or browsing systematically. The library's computer system handles the complex work of organizing and dividing the collection, while visitors enjoy a smooth, responsive experience that doesn't overwhelm them with information or make them wait for massive lists to load.</p>

            <h3>Examples</h3>
            <p><strong>Repository with pagination support:</strong></p>
            <pre><code class="language-java">public interface BookRepository extends JpaRepository&lt;Book, Long&gt; {
    Page&lt;Book&gt; findByAuthorName(String authorName, Pageable pageable);
    Page&lt;Book&gt; findByCategory(String category, Pageable pageable);
}</code></pre>

            <p><strong>Using pagination in service:</strong></p>
            <pre><code class="language-java">Pageable pageable = PageRequest.of(0, 10, Sort.by("title"));
Page&lt;Book&gt; bookPage = bookRepository.findByCategory("Fiction", pageable);
List&lt;Book&gt; books = bookPage.getContent();  // Current page items
</code></pre>

            <p><strong>Sorting with multiple criteria:</strong></p>
            <pre><code class="language-java">Sort sort = Sort.by("category").ascending().and(Sort.by("publicationDate").descending());
Pageable pageable = PageRequest.of(0, 20, sort);
</code></pre>

            <p><strong>Getting pagination information:</strong></p>
            <pre><code class="language-java">Page&lt;Book&gt; page = bookRepository.findAll(pageable);
int totalPages = page.getTotalPages();
long totalElements = page.getTotalElements();
boolean hasNext = page.hasNext();
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="lazy-eager-loading" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Lazy vs Eager Loading</h2>
            <h3>Definition</h3>
            <p>Loading strategies control when related entities are fetched from the database. Lazy loading (default for collections) fetches related data only when accessed, while eager loading fetches everything immediately. The choice affects performance significantly: lazy loading reduces initial query time but can cause N+1 query problems, while eager loading may fetch unnecessary data but guarantees everything is available. Understanding and controlling fetch strategies is crucial for application performance.</p>

            <h3>Analogy</h3>
            <p>Think of lazy vs eager loading like two different approaches to packing for a family vacation. Eager loading is like packing everyone's suitcases completely before leaving the house - you grab all the clothes, toiletries, and accessories for every family member right away. This takes longer upfront, and you might pack things you won't need, but once you're at your destination, everything is immediately available. Lazy loading is like packing just the essentials initially, then going back to get specific items only when someone asks for them. This gets you out the door faster, but you might end up making multiple trips back home when different family members realize they need their favorite shirt or special shoes. The best approach depends on your trip length, packing space, and how often people will need their extra items.</p>

            <h3>Examples</h3>
            <p><strong>Default lazy loading for collections:</strong></p>
            <pre><code class="language-java">@Entity
public class Author {
    @OneToMany(mappedBy = "author", fetch = FetchType.LAZY)  // Default
    private List&lt;Book&gt; books;  // Loaded only when accessed
}
</code></pre>

            <p><strong>Eager loading for immediate access:</strong></p>
            <pre><code class="language-java">@Entity
public class Order {
    @ManyToOne(fetch = FetchType.EAGER)
    private Customer customer;  // Always loaded with order
}
</code></pre>

            <p><strong>Solving N+1 query problem with JOIN FETCH:</strong></p>
            <pre><code class="language-java">@Query("SELECT a FROM Author a JOIN FETCH a.books WHERE a.id = :id")
Optional&lt;Author&gt; findAuthorWithBooks(@Param("id") Long id);</code></pre>

            <p><strong>Entity graph for complex fetching:</strong></p>
            <pre><code class="language-java">@EntityGraph(attributePaths = {"books", "profile"})
@Query("SELECT a FROM Author a WHERE a.name = :name")
List&lt;Author&gt; findAuthorWithBooksAndProfile(@Param("name") String name);</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="n-plus-one-problem" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>N+1 Query Problem</h2>
            <h3>Definition</h3>
            <p>The N+1 query problem occurs when your application executes one query to fetch N parent records, then executes N additional queries to fetch related data for each parent record, resulting in N+1 total database queries instead of a more efficient approach. This happens commonly with lazy loading when you iterate over a collection of entities and access their lazy-loaded relationships. The problem severely impacts performance as the number of parent records grows, turning what should be 2 queries into potentially hundreds or thousands of queries.</p>

            <h3>Analogy</h3>
            <p>The N+1 query problem is like a inefficient mail delivery system in a large apartment building. Instead of the mail carrier making one trip to collect all mail for the building (1 query) and then delivering everything in a single efficient route through all floors (1 more query), imagine if the carrier made one trip to get the list of residents (1 query), then made a separate round trip back to the post office for each individual resident's mail (N additional queries). So for a 100-unit building, instead of 2 trips total, the carrier makes 101 trips! This becomes exponentially more wasteful as the building gets larger. The residents get their mail eventually, but the system is incredibly inefficient, causing traffic jams, wasted fuel, and frustrated postal workers. A smart mail system would gather all the information needed in just a couple of efficient trips, just like how proper database query optimization should work.</p>

            <h3>Examples</h3>
            <p><strong>N+1 Problem Example - The Bad Way:</strong></p>
            <pre><code class="language-java">// This triggers N+1 queries!
List&lt;Author&gt; authors = authorRepository.findAll();  // 1 query to get authors
for (Author author : authors) {
    System.out.println(author.getBooks().size());   // N queries (one per author)
}
// Result: 1 + N queries instead of 2 queries</code></pre>

            <p><strong>Solution 1: JOIN FETCH in JPQL:</strong></p>
            <pre><code class="language-java">@Query("SELECT DISTINCT a FROM Author a JOIN FETCH a.books")
List&lt;Author&gt; findAllAuthorsWithBooks();

// Usage - only 1 query total!
List&lt;Author&gt; authors = authorRepository.findAllAuthorsWithBooks();
for (Author author : authors) {
    System.out.println(author.getBooks().size());  // No additional queries
}</code></pre>

            <p><strong>Solution 2: @EntityGraph annotation:</strong></p>
            <pre><code class="language-java">@EntityGraph(attributePaths = {"books"})
@Query("SELECT a FROM Author a")
List&lt;Author&gt; findAllWithBooks();

// This eagerly fetches books with authors in 1 query</code></pre>

            <p><strong>Solution 3: @BatchSize for collections:</strong></p>
            <pre><code class="language-java">@Entity
public class Author {
    @OneToMany(mappedBy = "author", fetch = FetchType.LAZY)
    @BatchSize(size = 10)  // Fetches up to 10 collections at once
    private List&lt;Book&gt; books;
}
// Reduces N+1 to 1 + (N/10) queries</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="transaction-management" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Transaction Management</h2>
            <h3>Definition</h3>
            <p>Transaction management in JPA ensures a sequence of operations either complete successfully as a group or have no effect at all, maintaining data integrity. It involves defining boundaries for a transaction, typically at the service layer, and using annotations like @Transactional to manage the commit or rollback of changes. Proper transaction management is crucial for applications with complex data changes, ensuring that all parts of a operation succeed or fail together.</p>

            <h3>Analogy</h3>
            <p>Think of transaction management like a safety net for a high-wire performer. The performer (your application) carefully walks the tightrope (executes operations), knowing that if they stumble (an error occurs), the safety net (transaction management) will catch them, preventing a dangerous fall (data corruption). Just as the safety net ensures the performer can complete their act safely, transaction management ensures your application's operations complete successfully, preserving the integrity and consistency of your data.</p>

            <h3>Examples</h3>
            <p><strong>Basic transaction management:</strong></p>
            <pre><code class="language-java">@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void registerUser(User user) {
        userRepository.save(user);
        // Other operations...
    }
}
</code></pre>

            <p><strong>Rollback on runtime exception:</strong></p>
            <pre><code class="language-java">@Service
public class OrderService {
    @Autowired
    private OrderRepository orderRepository;

    @Transactional
    public void processOrder(Order order) {
        orderRepository.save(order);
        if (order.getTotal() > 1000) {
            throw new RuntimeException("Order too expensive");  // Triggers rollback
        }
    }
}
</code></pre>

            <p><strong>Read-only transactions:</strong></p>
            <pre><code class="language-java">@Transactional(readOnly = true)
public List&lt;User&gt; getAllUsers() {
    return userRepository.findAll();
}
</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="connection-management" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Connection Management</h2>
            <h3>Definition</h3>
            <p>Connection management in JPA involves configuring and optimizing how your application connects to and communicates with the database. This includes managing connection pools, setting connection timeouts, configuring connection validation, and monitoring connection health. A connection pool maintains a set of reusable database connections to avoid the overhead of creating and destroying connections for each database operation. Proper connection management is crucial for application performance, scalability, and resource utilization.</p>

            <h3>Analogy</h3>
            <p>Connection management is like managing a fleet of delivery trucks for a busy restaurant. Instead of buying a new truck every time you need to make a delivery (creating a new connection), you maintain a pool of trucks that drivers can use and return when finished (connection pool). You keep enough trucks available to handle peak hours without having too many sitting idle during slow periods. Each truck is regularly inspected and maintained (connection validation), and you monitor their usage to optimize your fleet size. If a truck breaks down, you remove it from service and potentially add a replacement (connection health monitoring). This system ensures fast, reliable deliveries while managing costs and resources efficiently.</p>

            <h3>Examples</h3>
            <p><strong>HikariCP connection pool configuration:</strong></p>
            <pre><code class="language-properties"># Connection pool settings
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=1200000
spring.datasource.hikari.connection-timeout=20000</code></pre>

            <p><strong>Connection validation:</strong></p>
            <pre><code class="language-properties"># Test connections before use
spring.datasource.hikari.connection-test-query=SELECT 1
spring.datasource.hikari.validation-timeout=3000</code></pre>

            <p><strong>Multiple datasource configuration:</strong></p>
            <pre><code class="language-java">@Configuration
public class DatabaseConfig {
    @Primary
    @Bean
    @ConfigurationProperties("spring.datasource.primary")
    public DataSource primaryDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean
    @ConfigurationProperties("spring.datasource.secondary")
    public DataSource secondaryDataSource() {
        return DataSourceBuilder.create().build();
    }
}</code></pre>

            <p><strong>Connection pool monitoring:</strong></p>
            <pre><code class="language-java">@Component
public class ConnectionPoolMonitor {
    @Autowired
    private HikariDataSource dataSource;

    @EventListener
    public void logPoolStats() {
        HikariPoolMXBean poolBean = dataSource.getHikariPoolMXBean();
        logger.info("Active connections: {}, Idle connections: {}",
                   poolBean.getActiveConnections(), poolBean.getIdleConnections());
    }
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="performance-optimization" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Performance Optimization</h2>
            <h3>Definition</h3>
            <p>JPA performance optimization involves reducing database queries, minimizing data transfer, and using appropriate caching strategies. Key techniques include using projections to fetch only needed fields, enabling query caching, optimizing fetch strategies, using batch operations for bulk updates, and monitoring query execution with SQL logging. Good performance requires understanding when and how your application accesses data, then optimizing those access patterns.</p>

            <h3>Analogy</h3>
            <p>Performance optimization is like optimizing your grocery shopping routine. Instead of making separate trips for each item (N+1 queries), you plan ahead and get everything in one efficient trip (JOIN FETCH). You use a shopping list with only what you need (projections) rather than wandering every aisle. You buy frequently used items in bulk (caching) and organize your route through the store for maximum efficiency (query optimization). You might even coordinate with neighbors to share trips for common items (batch operations). The goal is to get everything you need with minimal time and effort, using smart planning and efficient strategies rather than just working harder.</p>

            <h3>Examples</h3>
            <p><strong>Using projections for specific fields:</strong></p>
            <pre><code class="language-java">@Query("SELECT u.name, u.email FROM User u WHERE u.active = true")
List&lt;Object[]&gt; findActiveUserSummary();

// Or with interface projections
interface UserSummary {
    String getName();
    String getEmail();
}
</code></pre>

            <p><strong>Batch operations for performance:</strong></p>
            <pre><code class="language-java">@Modifying
@Query("UPDATE User u SET u.active = false WHERE u.lastLogin < :cutoffDate")
int deactivateInactiveUsers(@Param("cutoffDate") LocalDate cutoffDate);
</code></pre>

            <p><strong>Hibernate-specific optimizations:</strong></p>
            <pre><code class="language-java">// Enable query cache
spring.jpa.properties.hibernate.cache.use_query_cache=true

// Show SQL for debugging
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
</code></pre>

            <p><strong>Using @BatchSize for collection loading:</strong></p>
            <pre><code class="language-java">@Entity
public class Author {
    @OneToMany(mappedBy = "author")
    @BatchSize(size = 10)  // Load up to 10 collections at once
    private List&lt;Book&gt; books;
}</code></pre>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="summary" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Summary</h2>
            <p>You've now mastered advanced JPA and Hibernate concepts that are essential for building sophisticated, high-performance data-driven applications. From modeling complex entity relationships and writing custom queries to optimizing performance and managing database connections, these skills form the foundation of professional Java development. You've learned to navigate the trade-offs between lazy and eager loading, solve the N+1 query problem, implement proper transaction management, and optimize connection pools for scalability. The custom query techniques with JPQL and native SQL give you the flexibility to handle any data access requirement, while the performance optimization strategies ensure your applications can handle real-world loads efficiently. These advanced JPA features prepare you to architect data layers that are both powerful and maintainable, setting the stage for building secure, production-ready applications in the upcoming lessons on Spring Security and deployment strategies.</p>
          </section>

          <hr class="my-10 h-1 border-0 bg-slate-300 dark:bg-slate-700 rounded" />

          <section id="programming-challenge" class="prose prose-slate mt-8 max-w-none dark:prose-invert">
            <h2>Programming Challenge</h2>
            <div class="rounded-lg border border-slate-200 bg-slate-50 p-6 dark:border-slate-700 dark:bg-slate-800">
              <h3 class="mt-0">Challenge: Advanced E-commerce Data Model</h3>
              <p><strong>Task:</strong> Build a comprehensive e-commerce data model with complex relationships, custom queries, and performance optimizations.</p>

              <p><strong>Requirements:</strong></p>
              <ol>
                <li>Create entity relationships:</li>
                <li><code>Customer</code> ‚Üî <code>Order</code> (one-to-many)</li>
                <li><code>Order</code> ‚Üî <code>OrderItem</code> (one-to-many)</li>
                <li><code>Product</code> ‚Üî <code>Category</code> (many-to-many)</li>
                <li><code>Customer</code> ‚Üî <code>Address</code> (one-to-many, billing/shipping)</li>
                <li><code>Product</code> ‚Üî <code>Review</code> (one-to-many)</li>
                <li>Implement custom queries:</li>
                <li>Find top-selling products with total quantities sold</li>
                <li>Find customers who spent more than a certain amount</li>
                <li>Find products by category with average rating</li>
                <li>Monthly sales report with totals and order counts</li>
                <li>Add performance optimizations:</li>
                <li>Use appropriate fetch strategies</li>
                <li>Implement pagination for product listings</li>
                <li>Create projections for summary views</li>
                <li>Use JOIN FETCH to avoid N+1 queries</li>
                <li>Include advanced features:</li>
                <li>Audit fields (created/modified timestamps)</li>
                <li>Soft deletion for products and customers</li>
                <li>Calculated fields (order totals, average ratings)</li>
                <li>Custom validation annotations</li>
              </ol>

              <p><strong>Bonus features:</strong></p>
              <ul>
                <li>Implement product search with full-text search</li>
                <li>Add inventory tracking with stock levels</li>
                <li>Create customer loyalty points system</li>
                <li>Implement product recommendations based on purchase history</li>
                <li>Add comprehensive test suite for all custom queries</li>
              </ul>

              <p><strong>Learning Goals:</strong> Practice advanced entity modeling, complex relationship mapping, custom query development, performance optimization techniques, and building a realistic, scalable data architecture for a complex business domain.</p>
            </div>
          </section>

          <nav class="mt-12 flex items-center justify-between border-t border-slate-200/60 pt-6 dark:border-slate-800/60">
            <a href="lesson-13.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Previous</a>
            <a href="lesson-15.html" class="inline-flex items-center rounded-lg border border-slate-300 bg-white px-4 py-2 text-sm font-medium shadow-sm hover:bg-slate-50 active:scale-95 dark:border-slate-700 dark:bg-slate-900 dark:hover:bg-slate-800">Next</a>
          </nav>
        </div>
      </div>
    </main>

    <footer class="border-t border-slate-200/60 py-10 text-center text-sm text-slate-500 dark:border-slate-800/60 dark:text-slate-400">
      <div class="mx-auto max-w-7xl px-6">
        <p>¬© 2025 wassim lagnaoui. All rights reserved.</p>
      </div>
    </footer>

    <script>
      document.getElementById('themeToggle').addEventListener('click', function(){
        const r=document.documentElement; const d=r.classList.toggle('dark');
        try{localStorage.setItem('theme', d?'dark':'light');}catch{}
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      if (window.Prism && Prism.plugins && Prism.plugins.autoloader) {
        Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1/components/';
        Prism.highlightAll();
      }
    </script>
  </body>
</html>
